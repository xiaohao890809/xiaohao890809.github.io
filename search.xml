<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习基础之概率论]]></title>
    <url>%2F2018%2F03%2F07%2FThe-note-of-probability-theory%2F</url>
    <content type="text"><![CDATA[机器学习算法中有很多用到概率论知识的地方，比如贝叶斯定理，频繁挖掘，条件概率等，掌握好概率论的基础知识有利于更好的理解机器学习中的相关算法。 三箱零件，其中第一箱 10 个零件，第二箱 20 个零件，第三箱 15 个。检验结果表明第一箱有 1 个不合格，第二箱有 3 个不合格，第三箱有 2 个不合格，从中抽取一个零件，合格的概率有多少？ 记 $A_i$ 为从第 $i$ 个箱子拿的零件，拿到正品的事件记为B。$$\begin{align}P(B)&amp;=P(A_1)\cdot P(B|A_1)+P(A_2)\cdot P(B|A_2)+P(A_3)\cdot P(B|A_3)\\&amp;=P(A_1)+P(A_2)\cdot P(B|A_2)+P(A_3)\cdot P(B|A_3)\\&amp;=\frac{1}{3}\cdot \frac{9}{10}+\frac{1}{3}\cdot \frac{17}{20}+\frac{1}{3}\cdot \frac{13}{15}\\&amp;=0.872\end{align}$$问题：求逆向概率$P(A_{1}|B)$，抽到的这个合格品来自箱子 $A_{1}$ 的概率。$$\begin{align}P(A_{1}|B)&amp;=\frac{P(A_1\cdot B)}{P(B)}\\&amp;=\frac{P(A_1)\cdot P(B|A_1)}{P(B)}\\&amp;=\frac{\frac{1}{3}\cdot \frac{9}{10}}{P(B)}\\&amp;=\frac{0.3}{0.872}=0.344\end{align}$$ 注意条件概率 $P(B|A_1)$ 和联合概率 $P(A_1\cdot B)$ 的使用。 分类问题概述：通过对已知类别信息的数据进行学习后获得分类模型(classifier)，利用分类模型对未知类别信息的数据进行分类(classification)。 朴素贝叶斯分类算法举例——朴素贝叶斯(Naive Bayesian Model, NBM) $$\begin{cases}P(C_i|X)=\frac{P(X|C_i)\cdot P(C_i)}{P(X)}\\P(X|C_i)=\prod_{K=1}^{n}P(X_k|C_i)\\P(AB)=P(A)\cdot P(B)\\\end{cases}$$ $P(C_i|X)$: 后验概率 $P(X|C_i)$: 条件概率 $P(C_i)$: 最大似然估计 通过数据元组的各个属性表示(值)，计算出该数据元素属于$C_i$的概率。根据贝叶斯定理，将已知各属性表示求所属后验概率的问题转为已知所属类各属性表示组合的条件概率的问题。 需要对已标记类别的训练样本进行统计分析。对样本库数据计算各类的最大似然用以估计各类的先验概率。计算各属性值的条件概率。假设各属性间相互独立。 ID age income student credit class:buy 1 youth high no fair no 2 youth high no excellent no 3 middle high no fair yes 4 senior medium no fair yes 5 senior low yes fair yes 6 senior low yes excelent no 7 middle low yes excelent yes 8 youth medium no fair no 9 youth low yes fair yes 10 senior medium yes fair yes 11 youth medium yes excelent yes 12 middle medium no excelent yes 13 middle high yes fair yes 14 senior medium no excelent no 样本库中各类数据的先验概率：$$\begin{align}&amp;P(buy=yes)=\frac{9}{14}=0.643\\&amp;P(buy=no)=\frac{5}{14}=0.357\end{align}$$ 每一项属性值的条件概率：$$\begin{align}&amp;P(age=youth|buy=yes)=\frac{2}{9}=0.222\\&amp;P(age=youth|buy=no)=\frac{3}{5}=0.600\\&amp;P(income=medium|buy=yes)=\frac{4}{9}=0.444\\&amp;P(income=medium|buy=no)=\frac{2}{5}=0.400\\&amp;P(student=yes|buy=yes)=\frac{6}{9}=0.667\\&amp;P(student=yes|buy=no)=\frac{1}{5}=0.200\\&amp;P(credict=fair|buy=yes)=\frac{6}{9}=0.667\\&amp;P(credict=fair|buy=no)=\frac{2}{5}=0.400\end{align}$$ 求 $x=(youth,medium,yes,fair)$ 属于哪个类？假设各属性之间相互独立，求得测试数据属性向量的条件该概率：$$\begin{align}P(x|buy=yes)&amp;=P(age=youth|buy=yes)\\&amp;\cdot P(income=medium|buy=yes)\\&amp;\cdot P(student=yes|buy=yes)\\&amp;\cdot P(credit=fair|buy=yes)\\&amp;=0.222\cdot 0.444\cdot 0.667\cdot 0.667\\&amp;=0.044\end{align}$$ 同理：$$P(x|buy=no)=0.019$$ 选取能使以下公式取值最大的分类：$$P(C_i|x)=\frac{P(x|C_i)\cdot P(C_i)}{P(x)}$$ 其中 $P(x)$ 为该特征向量取值的先验概率，始终为常量。$$\begin{align}&amp;P(x|buy=yes)\cdot P(buy=yes)=0.044\cdot 0.643=0.082\\&amp;P(x|buy=no)\cdot P(buy=no)=0.019\cdot 0.357=0.007\end{align}$$所以判定测试数据属于 $buy=yes$类。 信息增益 摘自：数据挖掘中决策树的探讨(马秀红) 某装备维修项目如下： 役龄 价格 是否关键部件 可靠性 是否更换 &lt;=10 高 否 一般 否 &lt;=10 高 否 好 否 11-20 高 否 一般 是 &gt;20 中 否 一般 是 &gt;20 低 是 一般 是 &gt;20 高 是 好 是 11-20 低 是 一般 是 &lt;=10 中 是 一般 是 &lt;=10 低 是 一般 是 &gt;20 中 是 好 是 &lt;=10 中 否 一般 否 11-20 中 否 好 否 11-20 高 是 一般 是 11-20 中 否 好 否 使用信息增益进行属性选择，更新的备件数为$p$，不更新的备件数为$n$，则样本分类的期望信息： $$\begin{align}I(p,n)&amp;=I(9,5)\\&amp;=-\frac{9}{14}\cdot log_{2}\frac{9}{14}-\frac{5}{14}\cdot log_{2}\frac{5}{14}\\&amp;=0.940\end{align}$$ 计算各属性的熵： 役龄 $P_i$ $N_i$ $I(P_i,N_i)$ &lt;=10 2 3 0.971 11-20 3 2 0.971 &gt;20 4 0 0 有役龄划分为子集的熵： $$\begin{align}E(役龄)&amp;=\frac{5}{14}I(2,3)+\frac{5}{14}I(3,2)+\frac{4}{14}I(4,0)\\&amp;=0.6936\end{align}$$ 役龄为属性，具有3个不同取值的信息增益为： $$Gain(役龄)=I(p,n)-E(役龄)=0.2464$$ 同理： $$\begin{align}&amp;Gain(价格)=0.2098\\&amp;Gain(关键部件)=0.151\\&amp;Gain(可靠性)=0.10194\end{align}$$ 因此：$$Gain(可靠性)&lt;Gain(关键部件)&lt;Gain(价格)&lt;Gain(役龄)$$ 分类结果如图所示：]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VBA知识点总结]]></title>
    <url>%2F2018%2F03%2F01%2FThe-note-of-vba%2F</url>
    <content type="text"><![CDATA[VBA是一门比较早的语言了，用于处理 Office 办公软件的数据，不过最近听说以后会被 Python 代替（笑脸），现在总结一些使用 VBA 的过程遇到的一些问题以及解决办法。 常见错误问题1 此文件正由应用程序或另一用户使用。 解决方案：打开后记得做退出关闭操作。 12345678Set wdApp = GetObject(,"word.application")If wdApp is Nothing Then Sef wdApp = CreatObject("word.application") wdApp.Visible = TrueEnd IfwdApp.NormalTemplate.Saved = TruewdApp.QuitSet wdApp = Nothing 常用函数获取最大有效行数123456789101112Public Function GetLastRow(theSheet As Worksheet, ByVal col As Integer) As Integer Dim findreg As Range, ret As Range Set findreg = theSheet.Columns(col) Set ret = findreg.Find(what:="*", searchDirection:=xlPrevious) If Not ret Is Nothing Then GetLastRow = ret.Row Else GetLastRow = 0 End IfEnd Function 获取最大有效列数123456789101112Public Function GetLastCol(theSheet As Worksheet, ByVal row As Integer) As Integer Dim findreg As Range, ret As Range Set findreg = theSheet.Rows(row) Set ret = findreg.Find(what:="*", searchDirection:=xlPrevious) If Not ret Is Nothing Then GetLastCol = ret.Column Else GetLastCol = 0 End IfEnd Function 常用操作分割字符串1234567Dim a as VariantDim b as Varianta = Split("Red$Blue$Yellow","$")b = ubound(a)For i = 0 to b MsgBox a(i)Next 写入txt123456Sub test() Open ThisWorkbook.Path &amp; "1.txt" For Output(覆盖)/Append(追加) As #1 Print #1, "test2" Print #1, "test3" Close #1End Sub 查看下拉框所有内容1Range("D4").Validation.Formula1 下拉框进行赋值 第一种方法 1ComboBox1.List = Split("张三,李四",",") 第二种方法 123With ComboBox1 .AddItem("str1")End With 获取选定单元格所在的行和列12ActiveCell.RowActiveCell.Column]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则表达式知识积累]]></title>
    <url>%2F2018%2F02%2F27%2FThe-study-of-reg-expression%2F</url>
    <content type="text"><![CDATA[众所周知，正则表达式是非常重要的一个模块，在爬虫中用的好的话可以事半功倍，从复杂文本中根据规则去筛选数据等，掌握常用的一些正则通配符，从此刻开始。 正则表达式概念 使用单个字符串来描述匹配一系列符合某个句法规则的字符串 是对字符串操作的一种逻辑公式 应用场景：处理文本和数据 举例分析大括号匹配中括号中有任何一个字符，匹配里面的或者情况 123ma = re.match(r'\[[\w]\]','[a]')ret = re.findall(r'[abc]f','afufobfidlfodcfr')# ['af', 'bf', 'cf'] 含有换行正则修饰符re.S可以匹配包括换行在内的所有字符123456import recontent = '''Hello 1234567Word-This is a Regex Demo'''# 非贪婪匹配result = re.match('^He.*?(\d+).*?Demo$', content, re.S)print(result.group(1)) # 1234567 贪婪模式和非贪婪模式1234567import re# 贪婪模式，最大范围的匹配标准ret = re.findall(r'&lt;div&gt;(.*)&lt;/div&gt;','&lt;div&gt;hello&lt;/div&gt;&lt;div&gt;hello&lt;/div&gt;')print(ret) # ['hello&lt;/div&gt;&lt;div&gt;hello']# 非贪婪模式ret = re.findall(r'&lt;div&gt;(.*?)&lt;/div&gt;','&lt;div&gt;hello&lt;/div&gt;&lt;div&gt;hello&lt;/div&gt;')print(ret) # ['hello', 'hello'] 123456ma = re.match(r'[0-9][a-z]*','1bc') #全部匹配print(ma.group()) #1bcma = re.match(r'[0-9][a-z]*?','1bc') #最小匹配，0个print(ma.group()) #1ma = re.match(r'[0-9][a-z]+?','1bc') #最小匹配，一个print(ma.group()) #1b 忽略大小写1234ret = re.findall(r'&lt;div&gt;(hello)&lt;/div&gt;','&lt;div&gt;hello&lt;/DIV&gt;')print(ret) # []ret = re.findall(r'&lt;div&gt;(hello)&lt;/div&gt;','&lt;div&gt;hello&lt;/DIV&gt;',re.I)print(ret) # ['hello'] 匹配邮箱1mail = re.finall(r'\w+@\w+\.com|\w+@\w+\.cn|\w+@\w+\.net','...') 匹配多个12345ma = re.match(r'[a-zA-Z0-9]&#123;6&#125;','abc123')print(ma.group()) #abc123# 匹配6-10个字符ma = re.match(r'[a-zA-Z0-9]&#123;6,10&#125;','abc123456')print(ma.group()) #abc123456 | 的用法12ma = re.match(r'[\w]&#123;4,6&#125;@(126|163).com','immoc@126.com')print(ma.group()) #immoc@126.com findall的用法1234str2 = 'c++=100, java=90, python=80'info = re.findall(r'\d+',str2)print(info) #['100', '90', '80']print(sum([int(x) for x in info])) #270 sub的用法123456789def add1(match): val = match.group() num = int(val) + 1 return str(num)str1 = 'immodc vedio = 1001'# 将数字整体加1ret = re.sub(r'\d+',add1,str1)print(ret) #immodc vedio = 1002 split的用法123str1 = 'immoc:C C++ Java Python,C#'list1 = re.split(r':| |,', str1)print(list1) #['immoc', 'C', 'C++', 'Java', 'Python', 'C#'] 参考文献 python正则表达式]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBA实现Excel的笛卡尔积]]></title>
    <url>%2F2018%2F01%2F12%2FThe-decare-by-excel%2F</url>
    <content type="text"><![CDATA[最近有一个任务需求，就是把 Excel 里的两列元素，里面的元素有多个信息，将其分别拆分，然后取笛卡尔积，写到一个新的工作簿中。刚开始准备用 Python 实现的，后来想了下，VBA作为 Office 工具的原生态语言，何不用 VBA 实现呢，于是整理了下便写出来了，下面介绍下过程，为方便起见，弄了一些简易的数据，针对不同的数据需要做一些相应的调整。 Excel的原始数据如下： 整个 VBA 的代码框架如下： 类模块原始数据对应的首行信息，每一列对应一个元素，将其列出，作为一个新的数组。1234Public a As StringPublic b As StringPublic c As StringPublic d As String 常量123Public Const maxNum = 100000Public MyArr(maxNum) As New MyAttrPublic MyNum As Integer 主函数思路是分别拆分每一行的那两列元素，然后将得到的元素做两个循环，遍历写入新的数组中，然后将新的数组传到工作簿中。 获取最大行数123456789101112Public Function GetLastRow(theSheet As Worksheet, ByVal col As Integer) As Integer Dim findreg As Range, ret As Range Set findreg = theSheet.Columns(col) Set ret = findreg.Find(what:="*", searchDirection:=xlPrevious) If Not ret Is Nothing Then GetLastRow = ret.Row Else GetLastRow = 0 End IfEnd Function 写入数组元素123456789Public Function WriteMsg(a As String, b As String, c As String, d As String) MyArr(MyNum).a = a MyArr(MyNum).b = b MyArr(MyNum).c = c MyArr(MyNum).d = d MyNum = MyNum + 1End Function 主程序假设新的工作簿的名字叫Sheet2，并且首行元素已经事先写好。123456789101112131415161718192021222324252627282930313233343536373839404142434445Sub calc() Dim thisSheet As Worksheet Set thisSheet = ActiveSheet Dim lastRow As Integer lastRow = GetLastRow(thisSheet, 1) MyNum = 0 Dim a As Variant Dim b As Variant Dim c As Variant Dim d As Variant Dim tmp1 As String Dim tmp2 As String For i = 2 To lastRow a = Split(Range("B" &amp; i), ";") b = UBound(a) c = Split(Range("C" &amp; i), ";") d = UBound(c) For j = 0 To b tmp1 = a(j) For k = 0 To d tmp2 = c(k) WriteMsg Range("A" &amp; i), tmp1, tmp2, Range("D" &amp; i) Next Next Next MsgBox MyNum For i = 0 To MyNum - 1 Sheets("Sheet2").Range("A" &amp; i + 2) = MyArr(i).a Sheets("Sheet2").Range("B" &amp; i + 2) = MyArr(i).b Sheets("Sheet2").Range("C" &amp; i + 2) = MyArr(i).c Sheets("Sheet2").Range("D" &amp; i + 2) = MyArr(i).d NextEnd Sub 效果预览 文件链接笛卡尔积.xlsm]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经典排序法之Python版]]></title>
    <url>%2F2018%2F01%2F11%2FThe-classic-sorts%2F</url>
    <content type="text"><![CDATA[大学的时候学习的经典算法忘记差不多了，现在赶紧拾起来，基本算法往往是复杂算法的基础，牢记掌握才是王道。 冒泡排序 1234567def BubbleSorted(nums): length = len(nums) for i in range(length-1): for j in range(length-i-1): if nums[j]&gt;nums[j+1]: nums[j],nums[j+1] = nums[j+1],nums[j] return nums 思考：如果原来的列表是有序列表呢，能否优化一下呢？ 123456789101112def bubble_sort(input_list): """冒泡排序""" length = len(input_list) for j in range(length - 1): # 当列表已经是有序列表的，节省空间 count = 0 for i in range(length - j - 1): if input_list[i] &gt; input_list[i+1]: input_list[i], input_list[i+1] = input_list[i+1], input_list[i] count += 1 if count == 0: return 属性： 最优时间复杂度：$O(n)$ (表示遍历一次没有发现任何可以交换的元素，排序结束) 最坏时间复杂度：$O(n^2)$ 稳定性：稳定 插入排序 1234567891011def InsertSorted(nums): # 从第二元素开始直到最后一个元素 for i in range(1,len(nums)): tmp = nums[i] print(nums) j = i-1 while j &gt;= 0 and nums[j] &gt; tmp: nums[j+1] = nums[j] j = j - 1 nums[j+1] = tmp return nums 选择排序 12345678def SelectSorted(nums): for i in range(len(nums)-1): minIndex = i for j in range(i+1,len(nums)): if nums[j] &lt; nums[minIndex]: minIndex = j nums[i],nums[minIndex] = nums[minIndex],nums[i] return nums 图片来源：常用算法js版]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解Python版本]]></title>
    <url>%2F2017%2F12%2F31%2FThe-leetcode-of-python%2F</url>
    <content type="text"><![CDATA[记录 LeetCode 的算法习题，用 Python3 语言进行实现，Python还是很强大的，有些 built-in 函数很简洁，一行代码解决问题。 数学3的幂326. 3的幂给定一个整数，写一个函数来判断它是否是 3 的幂次方。进阶:你能不使用循环或者递归来完成本题吗？? 题解：123456def isPowerOfThree(n): """ :type n: int :rtype: bool """ return n&gt;0 and 1162261467%n == 0 学习要点： 最大正整数：$2^{31}-1$，寻找 3 的最大次幂数 此题疑似作弊 自除数728. 自除数自除数 是指可以被它包含的每一位数除尽的数。例如，128 是一个自除数，因为 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0。还有，自除数不允许包含 0 。给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。 示例 1:12输入： 上边界left = 1, 下边界right = 22输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] 注意:每个输入参数的边界满足 1 &lt;= left &lt;= right &lt;= 10000. 解题：1234def selfDividingNumbers(left, right): selfDivde = lambda num: '0' not in str(num) and all(num % int(item) == 0 for item in str(num)) return list(filter(selfDivde,range(left, right+1))) # return filter(selfDivde,range(left, right+1)) Python2的写法 注意：all([num % int(item) == 0 for item in str(num)])中的括号去掉了，这样子节省了一部分时间复杂度。 学习要点： lamba表达式 过滤器 filter 的用法 all函数的用法 计数质数204. 计数质数统计所有小于非负整数 n 的质数的数量。 示例:123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题：1234567891011121314151617181920def countPrimes(n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = [True] * n res[0] = res[1] = False tmpDict = &#123;&#125; for i in range(2, n): if res[i]: # 查看是否有因子，如果有因子的话，肯定不是质数 for j in range(2, (n-1)//i+1): if not i*j in tmpDict: # 是否出现重复的情况呢 tmpDict[i*j] = 'Yes' print('i*j:', i * j) res[i*j] = False return sum(res) 旋转函数396. 旋转函数给定一个长度为 n 的整数数组 A。假设 $B_{k}$ 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为:$F(k) = 0 \cdot B_k[0] + 1 \cdot B_k[1] + \dots + (n-1) \cdot B_k[n-1]$.计算 F(0), F(1), ..., F(n-1) 中的最大值。 注意:可以认为 n 的值小于 $10^5$。 Example:123456A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26. 题解：之前的思路是这样子的(不可取)，一次旋转列表，得到新的列表，然后用各自的元素乘以索引得到结果，后来发现这样子会列表溢出。1234567891011121314def maxRotateFunction(A): """ :type A: List[int] :rtype: int """ ret = sum(i * num for (i, num) in enumerate(A)) for i in range(1,len(A)): B = A[i:] + A[:i] # 或者下面两行代替，by 刘亮钧 # num = A.pop() # A.insert(0,num) # 下面的B改为A cal = sum(i * num for (i, num) in enumerate(B)) if cal &gt; ret: ret = cal return ret 后来参考了答案，不拼接列表，采取巧妙的方法计算出结果。123456789101112def maxRotateFunction(A): """ :type A: List[int] :rtype: int """ lMax = sum(i * num for (i, num) in enumerate(A)) totalSum = sum(A) rMax = lMax for i in range(len(A)-1,0,-1): lMax += (totalSum - A[i]*len(A)) rMax = max(lMax, rMax) return rMax 学习要点： 考虑操作列表会溢出的情形 enumerate的用法，返回两个值，一个是索引，一个是元素的值 最大交换670. 最大交换给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1:123输入: 2736输出: 7236解释: 交换数字2和数字7。 示例 2:123输入: 9973输出: 9973解释: 不需要交换。 注意:给定数字的范围是 $[0,10^8]$ 解题：12345678910111213def maximumSwap(num): """ :type num: int :rtype: int """ numList = list(str(num)) newList = sorted(str(num), reverse=True) for i in range(len(numList)): if numList[i] != newList[i]: numList[len(numList) - 1 - numList[::-1].index(newList[i])], numList[i] = \ numList[i], numList[len(numList) - 1 - numList[::-1].index(newList[i])] break return int(''.join(numList)) 学习要点： [1,2,6,6]中取最后一个 6 的索引的方法 交换顺序 a,b = b,a 的时候注意 index 的那个调换的数字必须放在前面的位置 求和两整数之和371. 两整数之和不使用运算符 + 和-，计算两整数a 、b之和。 示例:若 a = 1 ，b = 2，返回 3。 解题：123456789101112131415161718def getSum(a, b): """ :type a: int :type b: int :rtype: int """ # 32 bits integer max MAX = 0x7FFFFFFF # 32 bits interger min MIN = 0x80000000 # mask to get last 32 bits mask = 0xFFFFFFFF while b != 0: # ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask # if a is negative, get a's 32 bits complement positive first # then get 32-bit positive's Python complement negative return a if a &lt;= MAX else ~(a ^ mask) 路径最小路径和64. 最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 示例12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题：1234567891011121314151617181920def minPathSum(grid): """ :type grid: List[List[int]] :rtype: int """ m = len(grid) # 宽度 n = len(grid[0]) # 长度 # 第一列累加求和 for i in range(1,m): grid[i][0] += grid[i-1][0] # 第一行累加求和 for i in range(1,n): grid[0][i] += grid[0][i-1] # 依次往下往右取上面和左边的最小值进行累加求和 for i in range(1,m): for j in range(1,n): grid[i][j] += min(grid[i][j-1],grid[i-1][j]) return grid[-1][-1]# 类似百度地图的求最短路径 腾讯2018秋招精选数学与数字求众数169. 求众数给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。 示例112输入: [3,2,3]输出: 3 示例212输入: [2,2,1,1,1,2,2]输出: 2 解题：1234567891011121314151617def majorityElement(nums): """ :type nums: List[int] :rtype: int """ # 思路1：用字典进行存储 # dic = &#123;&#125; # for item in nums: # if item not in dic: # dic[item] = 1 # if dic[item] &gt; len(nums)//2: # return item # else: # dic[item] += 1 # 思路2：简介的思路，因为传入的众数总是存在 return sorted(nums)[len(nums)//2] 2的幂231. 2的幂给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 题解： 123456def isPowerOfTwo(n): """ :type n: int :rtype: bool """ return n &gt; 0 and not (n &amp; n-1) n &amp; n - 1 removes the left most bit of n. If an integer is power of 2, there is a single bit in the binary representation of n. e.g. 16 = b10000, 16 - 1 = b01111, and 16 &amp; 16 - 1 = b10000 &amp; b01111 = 0, also 16 != 0, based on these facts there is only one bit in b10000, so 16 is power of 2. 反转整数 7. 反转整数给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 注意:假设我们的环境只能存储 32 位有符号整数，其数值范围是 $[−2^{31}, 2^{31} − 1]$。根据这个假设，如果反转后的整数溢出，则返回 0。 解题1234567891011121314151617def reverse(x): """ :type x: int :rtype: int """ result = 0 pos_x = abs(x) while pos_x: result = result * 10 + pos_x % 10 # python3和python2的不同之处，这里求余数是小数，要转换成整数 pos_x = pos_x // 10 if result &gt;= 2147483647: return 0 return result if x &gt;= 0 else result * (-1) 只出现一次的数字136. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例112输入: [2,2,1]输出: 1 示例212输入: [4,1,2,1,2]输出: 4 解题：123456def singleNumber(nums): """ :type nums: List[int] :rtype: int """ return 2 * sum(set(nums)) - sum(nums) 回文数9. 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ 解题：123456789101112131415161718192021def isPalindrome(x): """ :type x: int :rtype: bool """ if x &lt; 0: return False x = str(x) length = len(x) for i in range(length//2): if x[i] != x[length - i - 1]: return False return True# 另外一种思路，将数字倒序，然后进行比较'''x = str(x)return True if x==x[::-1] else False''' 不转换成字符串 12345678910111213def isPalindrome2(x): num = x if (x &lt; 0): return False res = 0 while (x &gt; 0): # 从各位到高位依次取出 res = res * 10 res = res + x % 10 x = x // 10 return (num == res) 学习要点： 逆向字符串的表示方法 不使用字符串的转换方式要熟练 数组与字符串反转字符串344. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。 示例 1:12输入: &quot;hello&quot;输出: &quot;olleh&quot; 示例 2:12输入: &quot;A man, a plan, a canal: Panama&quot;输出: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 解题12345678910111213141516171819202122232425'''def reverseString(s): """ :type s: str :rtype: str """ return s[::-1]# 另一种方法，夹逼法则def reverseString(s): s_list = list(s) i,j = 0, len(s_list)-1 while i&lt;j: s_list[i],s_list[j] = s_list[j],s_list[i] i += 1 j -= 1 return ''.join(s_list)'''# 递归的方法def reverseString(s): l = len(s) if l &lt; 2: return s return reverseString(s[l//2:]) + reverseString(s[:l//2]) 学习要点： 多种角度，多种思路。 反转字符串中的单词III557. 反转字符串中的单词III给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例112输入: &quot;Let&apos;s take LeetCode contest&quot;输出: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 解题：12345678910111213def reverseWords(s): """ :type s: str :rtype: str """ # 空格切割 s.split() 与 s.split(' ') 等价 return ' '.join(s.split()[::-1])[::-1]# 方法二：效率低一点def reverseWords2(s): # return ' '.join(x[::-1] for x in s.split()) # lambda表达式解法 return ' '.join(map(lambda x : x[::-1], s.split())) 存在重复元素217. 存在重复元素给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例112输入: [1,2,3,1]输出: true 示例212输入: [1,2,3,4]输出: false 示例312输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解题：123456789def containsDuplicate(nums): """ :type nums: List[int] :rtype: bool """ # 去重前和去重后比较列表长度 return len(set(nums)) != len(nums) # 另外一种解法 # return True if len(set(nums)) &lt; len(nums) else False 有效的括号20. 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: &quot;()&quot;输出: true 示例 2:12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3:12输入: &quot;(]&quot;输出: false 示例 4:12输入: &quot;([)]&quot;输出: false 示例 5:12输入: &quot;&#123;[]&#125;&quot;输出: true 解题：1234567891011121314151617181920212223242526272829303132333435 def isValid(s): """ :type s: str :rtype: bool """ my_dict = &#123;']':'[', '&#125;':'&#123;',')':'('&#125; stack = [] for char in s: if char in my_dict.values(): stack.append(char) elif char in my_dict.keys(): if stack == [] or my_dict[char] != stack.pop(): return False else: return False return stack == []def isValid2(s): """ :type s: str :rtype: bool """ n = len(s) if n == 0: return True if n %2 != 0: return False if '&#123;&#125;' in s or '()' in s or '[]' in s: s.replace('()','').replace('[]','').replace('&#123;&#125;','') return s == '' 删除排序数组中的重复项26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:123给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:1234567891011为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题：123456789101112131415def removeDuplicates(nums): """ :type nums: List[int] :rtype: int """ dulNum = 0 for i in range(1,len(nums)): if nums[i] != nums[dulNum]: dulNum += 1 nums[dulNum] = nums[i] # 返回处理后数组的长度，前几位就是想要的结果 # print(nums) # print(dulNum+1) return dulNum+1 最长公共前缀14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题1234567891011121314151617181920212223242526272829def longestCommonPrefix(strs): """ :type strs: List[str] :rtype: str """ # 我的思路：先找出最大字符串的长度，然后按照这个长度一次取各个元素的前n个元素，看是否相等，用set去重即可 if len(strs) == 0: return "" min_len = min([len(i) for i in strs]) while min_len &gt; 0: new_str = [i[:min_len] for i in strs] if len(set(new_str)) == 1: return list(set(new_str))[0] else: min_len -= 1 return ""# 第二种方法def longestCommonPrefix2(strs): """ :type strs: List[str] :rtype: str """ sz, ret = zip(*strs), "" # looping corrected based on @StefanPochmann's comment below for c in sz: if len(set(c)) &gt; 1: break ret += c[0] return ret 最长回文子串 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例1123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot;也是一个有效答案。 示例212输入: &quot;cbbd&quot;输出: &quot;bb&quot; 解题：1234567891011121314151617181920212223def helper(s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1:r]def longestPalindrome(s): """ :type s: str :rtype: str """ res = "" for i in range(len(s)): # odd case, like "aba" tmp = helper(s, i, i) print('tmp1:',tmp) if len(tmp) &gt; len(res): res = tmp # even case, like "abba" tmp = helper(s, i, i + 1) # print('tmp2:',tmp) if len(tmp) &gt; len(res): res = tmp return res 两数之和 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题：1234567891011121314def twoSum(nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt;= 1: return False buff_dict = &#123;&#125; for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i 三数之和15. 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 $a，b，c$ ，使得 $a + b + c = 0 ？$ 找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 示例123456例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题：123456789101112131415161718192021222324def threeSum(nums): """ :type nums: List[int] :rtype: List[List[int]] """ # 当长度小于3时，直接返回空列表 if len(nums) &lt; 3: return [] # 进行排序处理 nums.sort() ret = set() for i,j in enumerate(nums[:len(nums)-2]): # 防止出现重复的情况 if i &gt; 1 and j == nums[i-1]: continue d = &#123;&#125; for v in nums[i+1:]: if v not in d: d[-j-v] = 1 else: ret.add((j,-v-j,v)) # 对于Python2而言，map(list,ret)即可 return [*map(list,ret)] 最接近的三数之和16. 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 题解123456789101112131415161718192021def threeSumClosest(nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() res = sum(nums[:3]) for i in range(len(nums)): l, r = i + 1, len(nums) - 1 while l &lt; r: s = sum((nums[i], nums[l], nums[r])) if abs(s - target) &lt; abs(res - target): res = s if s &lt; target: l += 1 elif s &gt; target: r -= 1 else: # break early return res return res 字符串相乘43. 字符串相乘给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1:12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2:12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 题解12345678910111213141516def multiply(num1, num2): """ :type num1: str :type num2: str :rtype: str """ res = [0]*(len(num1) + len(num2)) for i,e1 in enumerate(reversed(num1)): for j,e2 in enumerate(reversed(num2)): # res[i+j] += int(e1) * int(e2) res[i + j] += (ord(e1) - ord('0')) * (ord(e2) - ord('0')) res[i+j+1] += res[i+j] // 10 res[i+j] %= 10 print(res) while len(res) &gt; 1 and res[-1] == 0 : res.pop() return ''.join(map(str,res[::-1])) 螺旋矩阵54. 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1:1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2:1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 题解123456789101112131415161718192021222324252627282930def spiralOrder(matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ ret = [] # 注意单列的情况 while matrix: # 第一行数据 ret += matrix.pop(0) if matrix and matrix[0]: for row in matrix: # 最后一列数据，单个元素 ret.append(row.pop()) if matrix: # 最后一行数据 ret += matrix.pop()[::-1] if matrix and matrix[0]: # 最后一行数据，单个元素 for row in matrix[::-1]: ret.append(row.pop(0)) return ret# 方法二，谜一般的答案def spiralOrder2(matrix): return matrix and [*matrix.pop(0)] + spiralOrder2([*zip(*matrix)][::-1]) 螺旋矩阵II59. 螺旋矩阵II给定一个正整数 n，生成一个包含 1 到 $n^{2}$ 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例:1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 题解123456789101112131415161718192021222324252627'''(1) Create a matrix to store the coordinates(0,0) (0,1) (0,2)(1,0) (1,1) (1,2)(2,0) (2,1) (2,2)(2) Read it out using the trick of "Spiral Matrix I"(0,0) (0,1) (0,2) (1,2) (2,2) ...(3) Put 1, 2, 3, ... n**2 at these coordinates sequentially. Done.'''# 妙def generateMatrix(n): """ :type n: int :rtype: List[List[int]] """ # result = [[0 for i in range(n)] for j in range(n)] # 简写成下面的形式 result = [[0]*n for j in range(n)] coord = [[(i, j) for j in range(n)] for i in range(n)] count = 1 while coord: for x, y in coord.pop(0): result[x][y] = count count += 1 # python2的写法 coord = zip(*coord)[::-1] coord = list(zip(*coord))[::-1] return result 字符串转换整数8. 字符串转换整数(atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [$−2^{31}$, $2^{31}$ − 1]。如果数值超过这个范围，qing返回 INT_MAX ($2^{31}$ − 1) 或 INT_MIN ($−2^{31}$) 。 示例 1:12输入: &quot;42&quot;输出: 42 示例 2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4:1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−2^31)。 题解1234567891011121314def myAtoi(str): """ :type str: str :rtype: int """ str = list(str.strip()) if len(str) == 0: return 0 sign = -1 if str[0] == '-' else 1 if str[0] in ['-','+']: del str[0] ret, i = 0, 0 while i &lt; len(str) and str[i].isdigit(): ret = ret*10 + ord(str[i]) - ord('0') i += 1 return max(-2**31,min(sign*ret, 2**31-1)) 盛最多水的容器11. 盛最多水的容器给定 n 个非负整数 $a_{1}，a_{2}，…，a_{n}$，每个数代表坐标中的一个点 $(i, a_{i})$ 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 $(i, a_{i})$ 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 1:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 题解1234567891011121314151617181920212223242526272829303132333435def maxArea(height): """ :type height: List[int] :rtype: int """ max_area = area = 0 left, right = 0, len(height) - 1 while left &lt; right: l, r = height[left], height[right] if l &lt; r: area = l*(right - left) while height[left] &lt;= l: left += 1 else: area = r*(right - left) # 注意right减少后不要越界 while height[right] &lt;= r and right: right -= 1 if area &gt; max_area: max_area = area return max_area# 第二种方法，超级简洁的方法def maxArea2(height): L,R,width,res = 0, len(height)-1, len(height)-1,0 for w in range(width,0,-1): if height[L] &lt; height[R]: res,L = max(w*height[L],res),L+1 else: res,R = max(w*height[R],res),R-1 return res 除自身以外数组的乘积238. 除自身以外数组的乘积给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例 1:12输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 题解1234567891011121314151617181920212223242526def productExceptSelf(nums): """ :type nums: List[int] :rtype: List[int] """ p = 1 n = len(nums) res = [] for i in range(n): res.append(p) p = p*nums[i] p = 1 for i in range(n-1,-1,-1): res[i] *= p p = p*nums[i] return res# 第二种方法，更为简洁def productExceptSelf2(nums): A,B = [1]*len(nums), [1]*len(nums) for i in range(1,len(nums)): A[i] = A[i-1]*nums[i-1] B[-i-1] = B[-i]*nums[-i] return [i*j for i,j in zip(A,B)] 寻找两个有序数组的中位数 4. 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(log(m + n))$。你可以假设 nums1 和 nums2 不会同时为空。 示例 1:123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 题解1234567891011121314151617181920212223242526272829303132333435def findMedinums1nSortednums1rrnums1ys(nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: flonums1t """ l = len(nums1) + len(nums2) if l % 2 == 1: return kth(nums1, nums2, l // 2) else: return (kth(nums1, nums2, l // 2) + kth(nums1, nums2, l // 2 - 1)) / 2.def kth(nums1, nums2, k): if not nums1: return nums2[k] if not nums2: return nums1[k] inums1, inums2 = len(nums1) // 2, len(nums2) // 2 mnums1, mnums2 = nums1[inums1], nums2[inums2] # when k is nums2igger thnums1n the sum of nums1 nums1nd nums2's medinums1n indices if inums1 + inums2 &lt; k: # if nums1's medinums1n is nums2igger thnums1n nums2's, nums2's first hnums1lf doesn't include k if mnums1 &gt; mnums2: return kth(nums1, nums2[inums2 + 1:], k - inums2 - 1) else: return kth(nums1[inums1 + 1:], nums2, k - inums1 - 1) # when k is smnums1ller thnums1n the sum of nums1 nums1nd nums2's indices else: # if nums1's medinums1n is nums2igger thnums1n nums2's, nums1's second hnums1lf doesn't include k if mnums1 &gt; mnums2: return kth(nums1[:inums1], nums2, k) else: return kth(nums1, nums2[:inums2], k) 合并两个有序数组88. 合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例:1234输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 题解123456789101112131415def merge(nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: None Do not return anything, modify nums1 in-place instead. """ while n: if m and nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 排序与搜索二叉树的最大深度104. 二叉树的最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 示例:12345678给定二叉树 [3,9,20,null,null,15,7]， 3 / \ 9 20 / \ 15 7返回它的最大深度 3 。 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Nonedef maxDepth(root): """ :type root: TreeNode :rtype: int """ return 1 + max(maxDepth(root.left), maxDepth(root.right)) if root else 0# 第二种方法def maxDepth2(root): depth = 0 level = [root] if root else [] while level: depth += 1 queue = [] # 每一层打印出来 for el in level: if el.left: queue.append(el.left) if el.right: queue.append(el.right) level = queue return depth# 实例化root = TreeNode(3)root.left = TreeNode(9)root.right = TreeNode(20)root.right.left = TreeNode(15)root.right.right = TreeNode(7)root.left.left = TreeNode(20)root.left.right = TreeNode(13)# 第二种实例化方法from collections import namedtuple''' 1 / \ / \ / \ / \ 2 3 / \ / \ / \ / \ 4 5 6 N / \ / \ / \ 7 N N N 8 9/ \ / \ / \N N N N N N'''Node = namedtuple('node', ['val', 'left','right'])tree = Node(1, Node(2, Node(4, Node(7, None, None), None), Node(5, None, None)), Node(3, Node(6, Node(8, None, None), Node(9, None, None)), None))print(maxDepth2(root)) 排序链表 148. 排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1:12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 1:12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def merge(self, h1, h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next, tail, h1 = h1, h1, h1.next else: tail.next, tail, h2 = h2, h2, h2.next tail.next = h1 or h2 return dummy.next def sortList(self, head): if not head or not head.next: return head pre, slow, fast = None, head, head while fast and fast.next: pre, slow, fast = slow, slow.next, fast.next.next pre.next = None return self.merge(*map(self.sortList, (head, slow)))# 打印链表def printListNode(l): strList = '' while l != None: strList = strList + str(l.val) l = l.next # strList = strList[::-1] print(strList)currNode1 = ListNode1 = ListNode(1)currNode1.next = ListNode(8)currNode1 = currNode1.nextcurrNode1.next = ListNode(4)sol = Solution()printListNode(sol.sortList(ListNode1)) 搜索旋转排序数组33. 搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 题解1234567891011121314151617181920212223242526272829def search(nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if not nums: return -1 low, high = 0, len(nums) - 1 while low &lt;= high: # 注意python2用/ mid = (low + high) // 2 if target == nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 数组中的第K个最大元素215. 数组中的第K个最大元素在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1:12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 1:12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明:你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 题解12345678910111213141516171819202122# 递归的思路def findKthLargest(nums, k): """ :type nums: List[int] :type k: int :rtype: int """ # pivot = nums[0] # 这样似乎更快 pivot = nums[len(nums) // 2] left = [l for l in nums if l &lt; pivot] equal = [e for e in nums if e == pivot] right = [r for r in nums if r &gt; pivot] if k &lt;= len(right): return findKthLargest(right, k) elif (k - len(right)) &lt;= len(equal): return equal[0] else: return findKthLargest(left, k - len(right) - len(equal)) 二叉搜索树中第K小的元素230. 二叉搜索树中第K小的元素给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 题解12345678910111213141516171819202122232425262728def kthSmallest(root, k): stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right# 方法二def kthSmallest2(self, root, k): self.k = k self.res = None self.helper(root) return self.resdef helper(self, node): if not node: return self.helper(node.left) self.k -= 1 if self.k == 0: self.res = node.val return self.helper(node.right) 动态规划买卖股票的最佳时机121. 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 示例 1:1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 题解1234567891011121314151617181920212223242526272829# 自己的思路：从前往后遍历寻找，直到找到相差最大的数为止def maxProfit(prices): """ :type prices: List[int] :rtype: int """ # 这种算法超出时间限制了 if len(prices) &lt;= 1: return 0 maxPrice = [] for i in range(len(prices)-1): tmpPriceList = [x-prices[i] for x in prices[i+1:]] maxPrice.extend(tmpPriceList) print(maxPrice) # 最大差值为负数的时候利润应该为0 return max(max(maxPrice),0)# 参考答案def maxProfit(prices): """ :type prices: List[int] :rtype: int """ maxProfit,minPrice = 0,float('inf') for price in prices: minPrice = min(minPrice, price) profit = price - minPrice maxProfit = max(maxProfit,profit) return maxProfit 学习要点： 注意考虑时间限制 充分利用前后之前的数字关系 买卖股票的最佳时机 II122. 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题：12345678910111213141516def maxProfit(prices): """ :type prices: List[int] :rtype: int """ if not prices or len(prices) == 1: return 0 profit = 0 for i in range(1,len(prices)): if prices[i] &gt; prices[i-1]: profit += prices[i] - prices[i-1] return profit# 第二种方法def maxProfit2(prices): return sum(max(prices[i]-prices[i-1],0) for i in range(1,len(prices))) 爬楼梯70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 示例 1:12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2:123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def climbStairs(n): """ :type n: int :rtype: int """ # 超过时间限制了 if n == 1: return 1 if n == 2: return 2 return climbStairs(n-1) + climbStairs(n-2)# 第二种方法def climbStairs2(n): """ :type n: int :rtype: int """ if n == 1: return 1 res = [-1 for i in range(n)] res[0], res[1] = 1, 2 return helper(n - 1, res)def helper(n, res): if res[n] == -1: return helper(n - 2, res) + helper(n - 1, res) else: return res[n]# 第三种方法def climbStairs3(n): """ :type n: int :rtype: int """ # 斐波那契数列 if n == 1: return 1 res = [0 for i in range(n)] res[0], res[1] = 1, 2 for i in range(2, n): res[i] = res[i-1] + res[i-2] return res[-1]# 第四种方法def climbStairs4(n): """ :type n: int :rtype: int """ # 斐波那契数列 a, b = 1, 1 for i in range(n): a, b = b, a+b return a 最大子序和53. 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶:如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题：123456789101112131415def maxSubArray(nums): """ :type nums: List[int] :rtype: int """ for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i] + nums[i-1]) return max(nums)# 第二种方法def maxSubArray2(nums): for i in range(1, len(nums)): if nums[i-1] &gt; 0: nums[i] += nums[i-1] return max(nums) 不同路径62. 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？说明：m 和 n 的值均不超过 100。 示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 1:12输入: m = 7, n = 3输出: 28 解题：123456789101112131415161718192021222324252627# 动态规划，可以将二维数组优化成一维数组进行def uniquePaths(m, n): """ :type m: int :type n: int :rtype: int """ if not m or not n: return 0 cur = [1] * n for i in range(1, m): for j in range(1, n): cur[j] += cur[j-1] return cur[-1]# 动态规划解法def uniquePaths2(m, n): """ :type m: int :type n: int :rtype: int """ Dp = [[1] * n] * m for i in range(1, m): for j in range(1, n): Dp[i][j] = Dp[i - 1][j] + Dp[i][j - 1] return Dp[m - 1][n - 1] 子集78. 子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。 示例123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题：1234567891011def subsets(nums): """ :type nums: List[int] :rtype: List[List[int]] """ # 可以不用进行排序 # nums.sort() result = [[]] for num in nums: result += [i + [num] for i in result] return result 回溯算法括号生成22. 括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 示例:12345678例如，给出 n = 3，生成结果为：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 解题：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 方法1def generateParenthesis(n): """ :type n: int :rtype: List[str] """ def genreate(p, left, right, paren=[]): if left: # 不能加上return genreate(p + '(', left - 1, right) if right &gt; left: # 不能加上return genreate(p + ')', left, right - 1) if not right: # paren += p, # 上面跟下面是等价的 paren += [p] return paren return genreate('', n, n)# 方法2def generateParenthesis2(n): """ :type n: int :rtype: List[str] """ # 真正的生成器 def generate(p, left, right): if right &gt;= left &gt;= 0: if not right: yield p for q in generate(p + '(', left - 1, right): yield q for q in generate(p + ')', left, right - 1): yield q return list(generate('', n, n))# 方法3def generateParenthesis3(n): """ :type n: int :rtype: List[str] """ dp = [[] for i in range(n + 1)] dp[0].append('') for i in range(n + 1): for j in range(i): dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]] return dp[n] 子集与前面重复 全排列46. 全排列给定一个没有重复数字的序列，返回其所有可能的全排列。 示例:12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题：1234567891011121314151617181920212223242526272829import itertoolsdef permute(nums): """ :type nums: List[int] :rtype: List[List[int]] """ perms = [[]] for n in nums: perms_new = [] for perm in perms: for i in range(len(perm)+1): perms_new.append(perm[:i] + [n] + perm[i:]) perms = perms_new return perms# 递归的思想，后面的[[]]不懂def permute2(nums): return [[n] + p for i,n in enumerate(nums) for p in permute2(nums[:i] + nums[i+1:])] or [[]]def permute3(nums): return list(itertools.permutations(nums))def permute4(nums): return list(map(list, itertools.permutations(nums)))nums = [1,2,3]print(permute2(nums)) 格雷编码89. 格雷编码格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1:1234567输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2 123456对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例 2:12345输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657'''All you need is a bit of careful thought.Btw, it's extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview.Even if you do not solve the problem finally, the interviewer at least get to know what you're thinking.And if you don't get the problem right, he/she will have a chance to correct you.'''def grayCode(n): """ :type n: int :rtype: List[int] """ ''' from up to down, then left to right 0 1 11 110 10 111 101 100 start: [0] i = 0: [0, 1] i = 1: [0, 1, 3, 2] i = 2: [0, 1, 3, 2, 6, 7, 5, 4] ''' res = [0] for i in range(n): res += [x + pow(2, i) for x in reversed(res)] return res'''关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);如 n = 3: G(0) = 000, G(1) = 1 ^ 0 = 001 ^ 000 = 001G(2) = 2 ^ 1 = 010 ^ 001 = 011 G(3) = 3 ^ 1 = 011 ^ 001 = 010G(4) = 4 ^ 2 = 100 ^ 010 = 110G(5) = 5 ^ 2 = 101 ^ 010 = 111G(6) = 6 ^ 3 = 110 ^ 011 = 101G(7) = 7 ^ 3 = 111 ^ 011 = 100'''# 神一般的解答def grayCode2(n): return [(i &gt;&gt; 1) ^ i for i in range(2 ** n)]'''n = 1: [0,1]n = 2: [0,1]+ [2+0, 2+1][::-1] = [0,1,3,2]n = 3: [0,1,3,2] + [4 + 0, 4 +1, 4 +3, 4 + 2][::-1] = [0,1,3,2,6,7,5,4]'''# 递归的思想def grayCode3(n): res = [[0]] for i in range(1,n+1): res.append(res[i-1] + [2**(i-1) + j for j in res[i-1][::-1]]) return res[n]n = 2print(grayCode3(n)) 链表突击 反转链表 206. 反转链表反转一个单链表。 示例12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题：1234567891011121314151617181920212223242526272829303132333435363738394041class ListNode(object): def __init__(self, x): self.val = x self.next = None# 打印链表def printListNode(l): strList = '' while l != None: strList = strList + str(l.val) l = l.next # strList = strList[::-1] print(strList)def reverseList(head): """ :type head: ListNode :rtype: ListNode """ prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev# 第二种方法def _reverse(node,prev=None): if not node: return prev n = node.next node.next = prev return _reverse(n, node)def reverseList2(head): """ :type head: ListNode :rtype: ListNode """ return _reverse(head) 相交链表160. 相交链表编写一个程序，找到两个单链表相交的起始节点。如下面的两个链表：在节点 c1 开始相交。 示例 1:123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2:123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3:1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class ListNode(object): def __init__(self, x): self.val = x self.next = None# 打印链表def printListNode(l): strList = '' while l != None: strList = strList + str(l.val) l = l.next # strList = strList[::-1] print(strList)def getIntersectionNode(headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ ptA, ptB, jumpToNext = headA, headB, False while ptA and ptB: print(ptA,ptB) if ptA == ptB: return ptA ptA, ptB = ptA.next, ptB.next if not ptA and not jumpToNext: ptA, jumpToNext = headB, True if not ptB: ptB = headA return Nonedef getIntersectionNode2(headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if headA is None or headB is None: return None pa = headA # 2 pointers pb = headB while pa is not pb: # if either pointer hits the end, switch head and continue the second traversal, # if not hit the end, just move on to next pa = headB if pa is None else pa.next pb = headA if pb is None else pb.nextcurrNode1 = ListNode1 = ListNode(4)currNode1.next = ListNode(1)currNode1 = currNode1.nextcurrNode1.next = ListNode(8)currNode1 = currNode1.nextcurrNode1.next = ListNode(4)currNode1 = currNode1.nextcurrNode1.next = ListNode(5)# printListNode(ListNode1)currNode2 = ListNode2 = ListNode(5)currNode2.next = ListNode(0)currNode2 = currNode2.nextcurrNode2.next = ListNode(1)currNode2 = currNode2.nextcurrNode2.next = ListNode(8)currNode2 = currNode2.nextcurrNode2.next = ListNode(4)currNode2 = currNode2.nextcurrNode2.next = ListNode(5)# printListNode(ListNode2)# listA = [4,1,8,4,5]# listB = [5,0,1,8,4,5]ret = getIntersectionNode2(ListNode1, ListNode2)print(ret) 环形链表141. 环形链表给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1:123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2:123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3:123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 解题：123456789# If there is a cycle, fast will catch slow after some loops.def hasCycle(self, head): slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: # == 改成 is 呢 return True return False 环形链表II142. 环形链表II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。 示例 1:123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2:123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3:123输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题：12345678910111213def detectCycle(head): slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None while head != slow: slow = slow.next head = head.next return head 合并两个有序链表 21. 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例:12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ListNode(object): def __init__(self, x): self.val = x self.next = None# 打印链表def printListNode(l): strList = '' while l != None: strList = strList + str(l.val) l = l.next # strList = strList[::-1] print(strList)def mergeTwoLists(l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 and l2: if l1.val &gt; l2.val: l1, l2 = l2, l1 l1.next = mergeTwoLists(l1.next, l2) return l1 or l2# 第二种方法def mergeTwoLists2(l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2# 第三种方法def mergeTwoLists3(l1, l2): if not l1 or l2 and l1.val &gt; l2.val: l1, l2 = l2, l1 if l1: l1.next = mergeTwoLists(l1.next, l2) return l1currNode1 = ListNode1 = ListNode(1)currNode1.next = ListNode(2)currNode1 = currNode1.nextcurrNode1.next = ListNode(4)currNode2 = ListNode2 = ListNode(1)currNode2.next = ListNode(3)currNode2 = currNode2.nextcurrNode2.next = ListNode(4)# printListNode(ListNode1)# printListNode(ListNode2)printListNode(mergeTwoLists2(ListNode1, ListNode2)) 删除链表中的节点 237. 删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1:123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2:123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 解题：1234567891011121314151617181920212223242526272829303132class ListNode(object): def __init__(self, x): self.val = x self.next = None# 打印链表def printListNode(l): strList = '' while l != None: strList = strList + str(l.val) l = l.next # strList = strList[::-1] print(strList)def deleteNode(node): """ :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. """ node.val = node.next.val node.next = node.next.next# 初始化第一个链表currNode1 = ListNode1 = ListNode(2)currNode1.next = ListNode(4)currNode1 = currNode1.nextcurrNode1.next = ListNode(3)printListNode(ListNode1)deleteNode(ListNode1.next)printListNode(ListNode1) 旋转链表 61. 旋转链表给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1:12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2:1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 解题：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = None# 打印链表def printListNode(l): strList = '' while l != None: strList = strList + str(l.val) l = l.next # strList = strList[::-1] print(strList)def rotateRight(head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head: return None p = q = head l = 1 while p.next: p = p.next l += 1 p.next = head k %= l for _ in range(l-k-1): q = q.next ans = q.next q.next = None return ans# 初始化第一个链表currNode1 = ListNode1 = ListNode(2)currNode1.next = ListNode(4)currNode1 = currNode1.nextcurrNode1.next = ListNode(3)printListNode(ListNode1)printListNode(rotateRight(ListNode1,2)) 两数相加 2. 两数相加给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class ListNode: def __init__(self, x): self.val = x self.next = None# 打印链表def printListNode(l): strList = '' while l != None: strList = strList + str(l.val) l = l.next # strList = strList[::-1] print(strList)def addTwoNumbers(l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry,val = divmod(v1+v2+carry,10) n.next = ListNode(val) n = n.next return root.next# 初始化第一个链表currNode1 = ListNode1 = ListNode(2)currNode1.next = ListNode(4)currNode1 = currNode1.nextcurrNode1.next = ListNode(3)# 初始化第二个链表currNode2 = ListNode2 = ListNode(5)currNode2.next = ListNode(6)currNode2 = currNode2.nextcurrNode2.next = ListNode(4)printListNode(addTwoNumbers(ListNode1,ListNode2)) 学习要点： 链表的初始化形式 求和高位进1的用法 合并K个排序链表23. 合并K个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例:1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 解题123456789101112131415161718192021222324class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ from heapq import heappush, heappop, heapreplace, heapify dummy = node = ListNode(0) h = [(n.val, n) for n in lists if n] heapify(h) while h: v, n = h[0] if n.next is None: heappop(h) #only change heap size when necessary else: heapreplace(h, (n.next.val, n.next)) node.next = n node = node.next return dummy.next 附加Nim游戏292. Nim游戏你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 示例 1:1234输入: 4输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 解题1234567def canWinNim(n): """ :type n: int :rtype: bool """ return bool(n % 2) # return bool(b &amp; 3)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保持某些好的习惯]]></title>
    <url>%2F2017%2F09%2F26%2FSome-good-habits-need-to-insist%2F</url>
    <content type="text"><![CDATA[优秀是一种习惯，保持一个良好的习惯往往能引导一种健康的生活姿态，现在记录一些自己认为是比较好的一些习惯，自己经常去看看，用于监督和督促自己。 生活 一周至少运动两次（跑步，爬山，打球等） 晚上11点半准备看书，然后睡觉 一天至少三大杯水 平时多吃点水果 一个月清理一次房间 晚上睡前刷牙 技术 代码写完后多检查下注释有没有写全，没写的补上，以免以后都不知道自己当初写的啥 LeetCode过三遍 js和go语言了解下 正则表达式多熟悉 反思 每天问一遍自己，想进BAT吗，以你现在的能力能进BAT吗，不能的话哪些地方需要加强呢？ 工作 平时多看下面试相关的信息，刷刷题 把跟自己业务相关的数据库表多检查下 英语 熟读新概念英语第三册前30篇]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记录博客的第一天]]></title>
    <url>%2F2015%2F08%2F14%2FFirst-day%2F</url>
    <content type="text"><![CDATA[好久不见，大家好！很高兴，今天终于开通了这个博客，这期间也得到了不少网友的帮助。之前在网上找了很多模板，但是选来选去，最终还是定了这个模板，因为这个模板比较简洁，而且也符合我预期的效果。 首先要感谢 enml，我是引用了他的模板。 先把他的模板下载到本地，然后传到自己建立的仓库下就可以进行修改模板了。将一些基本的信息，比如名字，多说的 id 以及一些图标都加以修改即可。刚开始的模板的导航栏上没有留言板和关于我这一栏，我后来自己补上的。之前模板的一个出口的 page 被我删掉了，因为感觉那个功能不太实用。还有原来的评论系统貌似用的是国外的一个系统，我将其改为了多说的评论系统，非常好用！ 其次是感谢 liberize 的帮助 在他的帮助下，我在评论框的头像加上了炫酷的旋转效果，看起来非常漂亮。只是原作者是圆形的图标，而我这个背景如果用了圆形的头像，会有一个阴影在下面，看起来非常不舒服，于是我改为了方形的效果，默认下的头像旋转是没有阴影的，这一点我至今还是很疑惑。 再者感谢 tk 域名 博客搭建好了，但是域名太长，不太方便随时输入。所以也百度了很多资料，看到网上都是说加一个 CNAME 文件，然后把域名加上去，在去域名管理页面加一个 A 地址。折腾了半天也没有成功。最后发现前提应该是自己得有一个 .com 或者 .me 域名，但是我木有。于是乎这条路便走不通了。后来无意间看到 tk 域名的网址，听说进去可以免费注册域名，于是抱着试一试的态度进去了，后来发现其实根本不用那么麻烦，只有把自己的博客地址指向到你要注册的 .tk 域名就 ok 了。省去了很多步骤。而且最后的网页比之前的网页更加完整了，之前没显示出来额头像图标和 github 图标都显示出来了，太惊喜了。只是某些字体不知道怎么回事，还是显示不完美。不过这样已经很满足了。 最后感谢 liberize 和百度文库的帮助 模板本来已经弄得差不多了，后来想来想去看了别人的很多模板，都在首页有分页的功能（PS：分类和标签是没有这个功能的），于是自己也想加上，所以结合了好几个人的模板，最后把每一个标签换了个颜色，显得不是那么单调。最后文章也要截取部分显示在首页中，这部分调式了好久，最后用了下面这个代码搞定了。 1post.content | truncate:300 其实就是把中间一部分舍掉了，因为加上中间那一部分的话，是按照文本进行分割的，而我想保留自己原来的格式，于是只取后面一部分就搞定了。当理想的界面出现在 html 上的时候，那个感觉非常好。也许博客到现在格式方面已经差不多了。不过到后面估计还得修改一些小细节，不断地进步才有动力前进！ 总结 github 真是个不错的平台，幸好天朝没有进行封杀，里面的资源和牛人特别多。他们秉着开源的精神，无私地分享了自己得许多经验和代码。所以，学无止境，多学习，多总结肯定是没有错的。 但无论如何，万事开头难，希望自己能够坚持下去，记录生活点滴，同时也写一些技术类的博客，虽然比较菜，但是进步空间比较大，加油，耗子！ 另外本博客已经使用 hexo 主题，之前的 jekyll 已经不用了。因为这个框架的主题配置起来比较容易，不用修改很多地方。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>第一滴血</tag>
      </tags>
  </entry>
</search>

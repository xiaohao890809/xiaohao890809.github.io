<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="追寻原风景">
  
  
  
  <link rel="prev" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-25/" />
  <link rel="next" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-27/" />
  <link rel="canonical" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-26/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           第25讲：Flink 中 watermark 的定义和使用 | 枕霞惜友
       
  </title>
  <meta name="title" content="第25讲：Flink 中 watermark 的定义和使用 | 枕霞惜友">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xiaohao890809.github.io"
    },
    "articleSection" : "posts",
    "name" : "第25讲：Flink 中 watermark 的定义和使用",
    "headline" : "第25讲：Flink 中 watermark 的定义和使用",
    "description" : "第 08 课时我们提过窗口和时间的概念，Flink 框架支持事件时间、摄入时间和处理时间三种。Watermark（水印）的出现是用于处理数据从 Source 产生，再到转换和输出，在这个过程中由于网络和反压的原因导致了消息乱序问题。\n那么在实际的开发过程中，如何正确地使用 Watermark 呢？\n使用 Watermark 必知必会 Watermark 和事件时间 事件时间（Event Time）是数据产生的时间，这个时间一般在数据中自带，由消息的生产者生成。例如，我们的上游是 Kafka 消息，那么每个生成的消息中自带一个时间戳代表该条数据的产生时间，这个时间是固定的，从数据的诞生开始就一直携带。所以，我们在处理消息乱序的情况时，会用 EventTime 和 Watermark 进行配合使用。\n我们只需要一行代码，就可以在代码中指定 Flink 系统使用的时间类型为 EventTime：\nenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime); 那么为什么不用处理时间（Processing Time）和摄入时间（Ingestion Time）呢？\n处理时间（Processing Time）指的是数据被 Flink 框架处理时机器的系统时间，这个时间本身存在不确定性，比如因为网络延迟等原因。\n摄入时间（Ingestion Time）理论上处于事件时间（Event Time）和处理时间（Processing Time）之间，可以用来防止 Flink 内部处理数据发生乱序的情况，但是无法解决数据进入 Flink 之前的乱序行为。\n所以我们一般都会用 EventTime、WaterMark 和窗口配合使用来解决消息的乱序和延迟问题。\n水印的本质是时间戳 水印的本质是一个一个的时间戳，这个时间戳存在 DataStream 的数据流中，Watermark 的生成方式有两种：\n AssignerWithPeriodicWatermarks 生成周期水印，周期默认的时间是 200ms； AssignerWithPunctuatedWatermarks 按需生成水印。  当 Flink 系统中出现了一个 Watermark T，那么就意味着 EventTime \u0026lt;= T 的数据都已经到达。当 Wartermark T 通过窗口后，后续到来的迟到数据就会被丢弃。\n窗口触发和乱序时间 Flink 在用时间 \u002b 窗口 \u002b 水印来解决实际生产中的数据乱序问题，有如下的触发条件：",
    "inLanguage" : "en-us",
    "author" : "王知无",
    "creator" : "王知无",
    "publisher": "王知无",
    "accountablePerson" : "王知无",
    "copyrightHolder" : "王知无",
    "copyrightYear" : "2020",
    "datePublished": "2020-07-20 10:37:48 \u002b0000 UTC",
    "dateModified" : "2020-07-20 10:37:48 \u002b0000 UTC",
    "url" : "https:\/\/xiaohao890809.github.io\/2020\/2020-07-20-the-lessons-of-flink-26\/",
    "wordCount" : "547",
    "keywords" : [ "42讲轻松通关Flink", "枕霞惜友"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <div class="top-scroll-bar"></div>
    
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">第25讲：Flink 中 watermark 的定义和使用</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xiaohao890809.github.io" rel="author">王知无</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-07-20 itemprop="datePublished">July 20, 2020</time>
                </span>
                
        </div>
    </header>

    
          <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title"></h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#使用-watermark-必知必会">使用 Watermark 必知必会</a>
      <ul>
        <li><a href="#watermark-和事件时间">Watermark 和事件时间</a></li>
        <li><a href="#水印的本质是时间戳">水印的本质是时间戳</a></li>
        <li><a href="#窗口触发和乱序时间">窗口触发和乱序时间</a></li>
        <li><a href="#flink-消费-kafka-保证消息有序">Flink 消费 Kafka 保证消息有序</a></li>
      </ul>
    </li>
    <li><a href="#flink-预定义的时间戳提取器和水印发射器">Flink 预定义的时间戳提取器和水印发射器</a>
      <ul>
        <li><a href="#ascendingtimestampextractor-递增时间戳提取器">AscendingTimestampExtractor 递增时间戳提取器</a></li>
        <li><a href="#boundedoutofordernesstimestampextractor-允许特定数量延迟的提取器">BoundedOutOfOrdernessTimestampExtractor 允许特定数量延迟的提取器</a></li>
      </ul>
    </li>
    <li><a href="#案例">案例</a></li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>
<script type="text/javascript">
  window.onload = function () {
    var fix = $('.post-toc');
    var end = $('.post-comment');
    var fixTop = fix.offset().top, fixHeight = fix.height();
    var endTop, miss;
    var offsetTop = fix[0].offsetTop;
    $(window).scroll(function () {
      var docTop = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
      if (end.length > 0) {
        endTop = end.offset().top;
        miss = endTop - docTop - fixHeight;
      }
      if (fixTop < docTop) {
        fix.css({ 'position': 'fixed' });
        if ((end.length > 0) && (endTop < (docTop + fixHeight))) {
          fix.css({ top: miss });
        } else {
          fix.css({ top: 0 });
        }
      } else {
        fix.css({ 'position': 'absolute' });
        fix.css({ top: offsetTop });
      }
    })
  }
</script> 
    

    <script type="text/javascript">
            window.MathJax = {
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            TeX: {equationNumbers: {autoNumber: "AMS"}},
            showProcessingMessages: false,
            messageStyle: 'none'
        };
   </script>

    <script type="text/javascript" async src="/lib/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>

    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <p>第 08 课时我们提过窗口和时间的概念，Flink 框架支持事件时间、摄入时间和处理时间三种。Watermark（水印）的出现是用于处理数据从 Source 产生，再到转换和输出，在这个过程中由于网络和反压的原因导致了消息乱序问题。</p>
<p>那么在实际的开发过程中，如何正确地使用 Watermark 呢？</p>
<h2 id="使用-watermark-必知必会">使用 Watermark 必知必会</h2>
<h3 id="watermark-和事件时间">Watermark 和事件时间</h3>
<p>事件时间（Event Time）是数据产生的时间，这个时间一般在数据中自带，由消息的生产者生成。例如，我们的上游是 Kafka 消息，那么每个生成的消息中自带一个时间戳代表该条数据的产生时间，这个时间是固定的，从数据的诞生开始就一直携带。所以，我们在处理消息乱序的情况时，会用 EventTime 和 Watermark 进行配合使用。</p>
<p>我们只需要一行代码，就可以在代码中指定 Flink 系统使用的时间类型为 EventTime：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">env<span style="color:#f92672">.</span><span style="color:#a6e22e">setStreamTimeCharacteristic</span><span style="color:#f92672">(</span>TimeCharacteristic<span style="color:#f92672">.</span><span style="color:#a6e22e">EventTime</span><span style="color:#f92672">);</span>
</code></pre></div><p>那么为什么不用处理时间（Processing Time）和摄入时间（Ingestion Time）呢？</p>
<p>处理时间（Processing Time）指的是数据被 Flink 框架处理时机器的系统时间，这个时间本身存在不确定性，比如因为网络延迟等原因。</p>
<p>摄入时间（Ingestion Time）理论上处于事件时间（Event Time）和处理时间（Processing Time）之间，可以用来防止 Flink 内部处理数据发生乱序的情况，但是无法解决数据进入 Flink 之前的乱序行为。</p>
<p>所以我们一般都会用 EventTime、WaterMark 和窗口配合使用来解决消息的乱序和延迟问题。</p>
<h3 id="水印的本质是时间戳">水印的本质是时间戳</h3>
<p>水印的本质是一个一个的时间戳，这个时间戳存在 DataStream 的数据流中，Watermark 的生成方式有两种：</p>
<ul>
<li>AssignerWithPeriodicWatermarks 生成周期水印，周期默认的时间是 200ms；</li>
<li>AssignerWithPunctuatedWatermarks 按需生成水印。</li>
</ul>
<p>当 Flink 系统中出现了一个 Watermark T，那么就意味着 EventTime &lt;= T 的数据都已经到达。当 Wartermark T 通过窗口后，后续到来的迟到数据就会被丢弃。</p>
<h3 id="窗口触发和乱序时间">窗口触发和乱序时间</h3>
<p>Flink 在用时间 + 窗口 + 水印来解决实际生产中的数据乱序问题，有如下的触发条件：</p>
<ul>
<li>watermark 时间 &gt;= window_end_time；</li>
<li>在 [window_start_time,window_end_time) 中有数据存在，这个窗口是左闭右开的。</li>
</ul>
<p>但是有些业务场景需要我们等待一段时间，也就是接受一定范围的迟到数据，此时 allowedLateness 的设置就显得尤为重要。简单地说，allowedLateness 的设置就是对于那些水印通过窗口的结束时间后，还允许等待一段时间。</p>
<p>如果业务中的实际数据因为网络原因，乱序现象非常严重，allowedLateness 允许迟到的时间如果设置太小，则会导致很多次极少量数据触发窗口计算，严重影响数据的正确性。</p>
<h3 id="flink-消费-kafka-保证消息有序">Flink 消费 Kafka 保证消息有序</h3>
<p>我们在第 23 课时“Mock Kafka 消息并发送”中提过，可以认为 Kafka 中的一个 Topic 就是一个队列，每个 Topic 又会被分成多个 Partition，每个 Partition 中的消息是有序的。但是有的业务场景需要我们保障所有 Partition 中的消息有序，一般情况下需要把 Partition 的个数设置为一个，但这种情况是不能接受的，会严重影响数据的吞吐量。</p>
<p>但是，Flink 消费 Kafka 时可以做到数据的全局有序，也可以多个 Partition 并发消费，这就是 Flink 中的 Kafka-partition-aware 特性。</p>
<p>我们在使用这种特性生成水印时，水印会在 Flink 消费 Kafka 的消费端生成，并且每个分区的时间戳严格升序。当数据进行 Shuffle 时，水印的合并机制会产生全局有序的水印。</p>
<p><figure><img src="/images/ring.svg" data-src="/images/%E6%9C%89%E5%BA%8F%E7%9A%84%E6%B0%B4%E5%8D%B0.png" data-sizes="auto" alt="有序的水印" title="有序的水印" class="lazyload"><figcaption class="image-caption">有序的水印</figcaption></figure></p>
<p>我们从上图中可以看出，每个生成的水印是如何在多个分区的数据中进行传递的。</p>
<p>代码实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">FlinkKafkaConsumer09<span style="color:#f92672">&lt;</span>MyType<span style="color:#f92672">&gt;</span> kafkaSource <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FlinkKafkaConsumer09<span style="color:#f92672">&lt;&gt;(</span><span style="color:#e6db74">&#34;topic&#34;</span><span style="color:#f92672">,</span> schema<span style="color:#f92672">,</span> props<span style="color:#f92672">);</span>
kafkaSource<span style="color:#f92672">.</span><span style="color:#a6e22e">assignTimestampsAndWatermarks</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> AscendingTimestampExtractor<span style="color:#f92672">&lt;</span>MyType<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">extractAscendingTimestamp</span><span style="color:#f92672">(</span>MyType element<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> element<span style="color:#f92672">.</span><span style="color:#a6e22e">eventTimestamp</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">});</span>
DataStream<span style="color:#f92672">&lt;</span>MyType<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> env<span style="color:#f92672">.</span><span style="color:#a6e22e">addSource</span><span style="color:#f92672">(</span>kafkaSource<span style="color:#f92672">);</span>
</code></pre></div><h2 id="flink-预定义的时间戳提取器和水印发射器">Flink 预定义的时间戳提取器和水印发射器</h2>
<p>Flink 本身提供了两个预定义实现类去生成水印：</p>
<ul>
<li>AscendingTimestampExtractor 时间戳递增</li>
<li>BoundedOutOfOrdernessTimestampExtractor 处理乱序消息和延迟时间</li>
</ul>
<h3 id="ascendingtimestampextractor-递增时间戳提取器">AscendingTimestampExtractor 递增时间戳提取器</h3>
<p>AscendingTimestampExtractor 是周期性生成水印的一个简单实现，这种方式会产生严格递增的水印。它的实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AscendingTimestampExtractor</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> AssignerWithPeriodicWatermarks<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>
   <span style="color:#66d9ef">public</span> AscendingTimestampExtractor<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">withViolationHandler</span><span style="color:#f92672">(</span>MonotonyViolationHandler handler<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">violationHandler</span> <span style="color:#f92672">=</span> requireNonNull<span style="color:#f92672">(</span>handler<span style="color:#f92672">);</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
   <span style="color:#a6e22e">@Override</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">extractTimestamp</span><span style="color:#f92672">(</span>T element<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> elementPrevTimestamp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> newTimestamp <span style="color:#f92672">=</span> extractAscendingTimestamp<span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newTimestamp <span style="color:#f92672">&gt;=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimestamp</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
         <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimestamp</span> <span style="color:#f92672">=</span> newTimestamp<span style="color:#f92672">;</span>
         <span style="color:#66d9ef">return</span> newTimestamp<span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
         violationHandler<span style="color:#f92672">.</span><span style="color:#a6e22e">handleViolation</span><span style="color:#f92672">(</span>newTimestamp<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimestamp</span><span style="color:#f92672">);</span>
         <span style="color:#66d9ef">return</span> newTimestamp<span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>
   <span style="color:#f92672">}</span>
   <span style="color:#a6e22e">@Override</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> Watermark <span style="color:#a6e22e">getCurrentWatermark</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Watermark<span style="color:#f92672">(</span>currentTimestamp <span style="color:#f92672">==</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span> <span style="color:#f92672">?</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span> <span style="color:#f92672">:</span> currentTimestamp <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>该种水印的生成方式适用于那些数据本身的时间戳在每个并行的任务中是单调递增的，例如，我们上面使用 AscendingTimestampExtractor 处理 Kafka 多个 Partition 的情况。</p>
<p>一个简单的案例如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">DataStream<span style="color:#f92672">&lt;</span>MyEvent<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
DataStream<span style="color:#f92672">&lt;</span>MyEvent<span style="color:#f92672">&gt;</span> withTimestampsAndWatermarks <span style="color:#f92672">=</span>
    stream<span style="color:#f92672">.</span><span style="color:#a6e22e">assignTimestampsAndWatermarks</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> AscendingTimestampExtractor<span style="color:#f92672">&lt;</span>MyEvent<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
        <span style="color:#a6e22e">@Override</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">extractAscendingTimestamp</span><span style="color:#f92672">(</span>MyEvent element<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> element<span style="color:#f92672">.</span><span style="color:#a6e22e">getCreationTime</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
<span style="color:#f92672">});</span>
</code></pre></div><h3 id="boundedoutofordernesstimestampextractor-允许特定数量延迟的提取器">BoundedOutOfOrdernessTimestampExtractor 允许特定数量延迟的提取器</h3>
<p>我们在上面提过有些业务场景需要等待一段时间，也就是接受一定范围的迟到数据，此时 allowedLateness 的设置就显得尤为重要。这种提取器也是周期性生成水印的实现，接受 allowedLateness 作为参数。</p>
<p>它的实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BoundedOutOfOrdernessTimestampExtractor</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> AssignerWithPeriodicWatermarks<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">...</span>
   <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> maxOutOfOrderness<span style="color:#f92672">;</span>
   <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BoundedOutOfOrdernessTimestampExtractor</span><span style="color:#f92672">(</span>Time maxOutOfOrderness<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>maxOutOfOrderness<span style="color:#f92672">.</span><span style="color:#a6e22e">toMilliseconds</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
         <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Tried to set the maximum allowed &#34;</span> <span style="color:#f92672">+</span>
            <span style="color:#e6db74">&#34;lateness to &#34;</span> <span style="color:#f92672">+</span> maxOutOfOrderness <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;. This parameter cannot be negative.&#34;</span><span style="color:#f92672">);</span>
      <span style="color:#f92672">}</span>
      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxOutOfOrderness</span> <span style="color:#f92672">=</span> maxOutOfOrderness<span style="color:#f92672">.</span><span style="color:#a6e22e">toMilliseconds</span><span style="color:#f92672">();</span>
      <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">currentMaxTimestamp</span> <span style="color:#f92672">=</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxOutOfOrderness</span><span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">getMaxOutOfOrdernessInMillis</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">return</span> maxOutOfOrderness<span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
   <span style="color:#a6e22e">@Override</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> Watermark <span style="color:#a6e22e">getCurrentWatermark</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">// this guarantees that the watermark never goes backwards.
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">long</span> potentialWM <span style="color:#f92672">=</span> currentMaxTimestamp <span style="color:#f92672">-</span> maxOutOfOrderness<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>potentialWM <span style="color:#f92672">&gt;=</span> lastEmittedWatermark<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
         lastEmittedWatermark <span style="color:#f92672">=</span> potentialWM<span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Watermark<span style="color:#f92672">(</span>lastEmittedWatermark<span style="color:#f92672">);</span>
   <span style="color:#f92672">}</span>
   <span style="color:#a6e22e">@Override</span>
   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">extractTimestamp</span><span style="color:#f92672">(</span>T element<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> previousElementTimestamp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#66d9ef">long</span> timestamp <span style="color:#f92672">=</span> extractTimestamp<span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>timestamp <span style="color:#f92672">&gt;</span> currentMaxTimestamp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
         currentMaxTimestamp <span style="color:#f92672">=</span> timestamp<span style="color:#f92672">;</span>
      <span style="color:#f92672">}</span>
      <span style="color:#66d9ef">return</span> timestamp<span style="color:#f92672">;</span>
   <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>BoundedOutOfOrdernessTimestampExtractor 的构造器接收 maxOutOfOrderness 这个参数，该参数是指定我们接收的消息允许滞后的最大时间。</p>
<h2 id="案例">案例</h2>
<p>下面是一个接收 Kafka 消息进行处理，自定义窗口和水印的案例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">WindowWaterMark</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
        StreamExecutionEnvironment env <span style="color:#f92672">=</span> StreamExecutionEnvironment<span style="color:#f92672">.</span><span style="color:#a6e22e">createLocalEnvironment</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">//设置为eventtime事件类型
</span><span style="color:#75715e"></span>        env<span style="color:#f92672">.</span><span style="color:#a6e22e">setStreamTimeCharacteristic</span><span style="color:#f92672">(</span>TimeCharacteristic<span style="color:#f92672">.</span><span style="color:#a6e22e">EventTime</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">//设置水印生成时间间隔100ms
</span><span style="color:#75715e"></span>        env<span style="color:#f92672">.</span><span style="color:#a6e22e">getConfig</span><span style="color:#f92672">().</span><span style="color:#a6e22e">setAutoWatermarkInterval</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
        DataStream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> dataStream <span style="color:#f92672">=</span> env
                <span style="color:#f92672">.</span><span style="color:#a6e22e">socketTextStream</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;127.0.0.1&#34;</span><span style="color:#f92672">,</span> 9000<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">assignTimestampsAndWatermarks</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> AssignerWithPeriodicWatermarks<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">private</span> Long currentTimeStamp <span style="color:#f92672">=</span> 0L<span style="color:#f92672">;</span>
                    <span style="color:#75715e">//设置允许乱序时间
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">private</span> Long maxOutOfOrderness <span style="color:#f92672">=</span> 5000L<span style="color:#f92672">;</span>
                    <span style="color:#a6e22e">@Override</span>
                    <span style="color:#66d9ef">public</span> Watermark <span style="color:#a6e22e">getCurrentWatermark</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Watermark<span style="color:#f92672">(</span>currentTimeStamp <span style="color:#f92672">-</span> maxOutOfOrderness<span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span>
                    <span style="color:#a6e22e">@Override</span>
                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">extractTimestamp</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> l<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        String<span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">);</span>
                        <span style="color:#66d9ef">long</span> timeStamp <span style="color:#f92672">=</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">parseLong</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>1<span style="color:#f92672">]);</span>
                        currentTimeStamp <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>timeStamp<span style="color:#f92672">,</span> currentTimeStamp<span style="color:#f92672">);</span>
                        System<span style="color:#f92672">.</span><span style="color:#a6e22e">err</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,EventTime:&#34;</span> <span style="color:#f92672">+</span> timeStamp <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;,watermark:&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>currentTimeStamp <span style="color:#f92672">-</span> maxOutOfOrderness<span style="color:#f92672">));</span>
                        <span style="color:#66d9ef">return</span> timeStamp<span style="color:#f92672">;</span>
                    <span style="color:#f92672">}</span>
                <span style="color:#f92672">});</span>
        dataStream<span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MapFunction<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Tuple2<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;&gt;()</span> <span style="color:#f92672">{</span>
            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> Tuple2<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
                String<span style="color:#f92672">[]</span> split <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">split</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Tuple2<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;(</span>split<span style="color:#f92672">[</span>0<span style="color:#f92672">],</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">parseLong</span><span style="color:#f92672">(</span>split<span style="color:#f92672">[</span>1<span style="color:#f92672">]));</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">})</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">keyBy</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">window</span><span style="color:#f92672">(</span>TumblingEventTimeWindows<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>Time<span style="color:#f92672">.</span><span style="color:#a6e22e">seconds</span><span style="color:#f92672">(</span>5<span style="color:#f92672">)))</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">aggregate</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> AggregateFunction<span style="color:#f92672">&lt;</span>Tuple2<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span>Long<span style="color:#f92672">&gt;,</span> Object<span style="color:#f92672">,</span> Object<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
                    <span style="color:#f92672">...</span>
                <span style="color:#f92672">})</span>
                <span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">();</span>
        env<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;WaterMark Test Demo&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span><span style="color:#75715e">//
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>在这个案例中，我们使用的 AssignerWithPeriodicWatermarks 来自定义水印发射器和时间戳提取器，设置允许乱序时间为 5 秒，并且在一个 5 秒的窗口内进行聚合计算。
在这个案例中，可以看到如何正确使用 Flink 提供的 API 进行水印和时间戳的设置。</p>
<h2 id="总结">总结</h2>
<p>这一课时讲解了生产环境中正确使用 Watermark 需要注意的事项，并且介绍了如何保证 Kafka 消息的全局有序，Flink 中自定义的时间戳提取器和水印发射器；最后用一个案例讲解了如何正确使用水印和设置乱序事件。通过这一课时你可以学习到生产中设置水印的正确方法和原理。</p>
<p><a href="https://github.com/wangzhiwubigdata/quickstart">点击这里下载本课程源码</a>。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>追寻原风景 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-26/>https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-26/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://xiaohao890809.github.io/tags/42%E8%AE%B2%E8%BD%BB%E6%9D%BE%E9%80%9A%E5%85%B3flink/">
                    #42讲轻松通关Flink</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://xiaohao890809.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-25/" class="prev" rel="prev" title="第24讲：Flink 消费 Kafka 数据业务开发"><i class="iconfont icon-left"></i>&nbsp;第24讲：Flink 消费 Kafka 数据业务开发</a>
         
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-27/" class="next" rel="next" title="第26讲：Flink 中的聚合函数和累加器的设计和使用">第26讲：Flink 中的聚合函数和累加器的设计和使用&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
        
        
    </div>

</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2015 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://xiaohao890809.github.io">追寻原风景</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>













    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>

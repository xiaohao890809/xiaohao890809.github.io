<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="追寻原风景">
  
  
  
  <link rel="prev" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-09/" />
  <link rel="next" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-11/" />
  <link rel="canonical" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-10/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           第09讲：Flink 状态与容错 | 枕霞惜友
       
  </title>
  <meta name="title" content="第09讲：Flink 状态与容错 | 枕霞惜友">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xiaohao890809.github.io"
    },
    "articleSection" : "posts",
    "name" : "第09讲：Flink 状态与容错",
    "headline" : "第09讲：Flink 状态与容错",
    "description" : "这一课时我们主要讲解 Flink 的状态和容错。\n在 Flink 的框架中，进行有状态的计算是 Flink 最重要的特性之一。所谓的状态，其实指的是 Flink 程序的中间计算结果。Flink 支持了不同类型的状态，并且针对状态的持久化还提供了专门的机制和状态管理器。\n状态 我们在 Flink 的官方博客中找到这样一段话，可以认为这是对状态的定义：\n When working with state, it might also be useful to read about Flink’s state backends. Flink provides different state backends that specify how and where state is stored. State can be located on Java’s heap or off-heap. Depending on your state backend, Flink can also manage the state for the application, meaning Flink deals with the memory management (possibly spilling to disk if necessary) to allow applications to hold very large state.",
    "inLanguage" : "en-us",
    "author" : "王知无",
    "creator" : "王知无",
    "publisher": "王知无",
    "accountablePerson" : "王知无",
    "copyrightHolder" : "王知无",
    "copyrightYear" : "2020",
    "datePublished": "2020-07-20 10:21:48 \u002b0000 UTC",
    "dateModified" : "2020-07-20 10:21:48 \u002b0000 UTC",
    "url" : "https:\/\/xiaohao890809.github.io\/2020\/2020-07-20-the-lessons-of-flink-10\/",
    "wordCount" : "533",
    "keywords" : [ "42讲轻松通关Flink", "枕霞惜友"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <div class="top-scroll-bar"></div>
    
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">第09讲：Flink 状态与容错</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xiaohao890809.github.io" rel="author">王知无</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-07-20 itemprop="datePublished">July 20, 2020</time>
                </span>
                
        </div>
    </header>

    
          <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title"></h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#状态">状态</a></li>
    <li><a href="#flink-状态分类和使用">Flink 状态分类和使用</a></li>
    <li><a href="#状态后端种类和配置">状态后端种类和配置</a>
      <ul>
        <li><a href="#memorystatebackend">MemoryStateBackend</a></li>
        <li><a href="#fsstatebackend">FsStateBackend</a></li>
        <li><a href="#rocksdbstatebackend">RocksDBStateBackend</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>
<script type="text/javascript">
  window.onload = function () {
    var fix = $('.post-toc');
    var end = $('.post-comment');
    var fixTop = fix.offset().top, fixHeight = fix.height();
    var endTop, miss;
    var offsetTop = fix[0].offsetTop;
    $(window).scroll(function () {
      var docTop = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
      if (end.length > 0) {
        endTop = end.offset().top;
        miss = endTop - docTop - fixHeight;
      }
      if (fixTop < docTop) {
        fix.css({ 'position': 'fixed' });
        if ((end.length > 0) && (endTop < (docTop + fixHeight))) {
          fix.css({ top: miss });
        } else {
          fix.css({ top: 0 });
        }
      } else {
        fix.css({ 'position': 'absolute' });
        fix.css({ top: offsetTop });
      }
    })
  }
</script> 
    

    <script type="text/javascript">
            window.MathJax = {
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            TeX: {equationNumbers: {autoNumber: "AMS"}},
            showProcessingMessages: false,
            messageStyle: 'none'
        };
   </script>

    <script type="text/javascript" async src="/lib/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>

    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <p>这一课时我们主要讲解 Flink 的状态和容错。</p>
<p>在 Flink 的框架中，进行有状态的计算是 Flink 最重要的特性之一。所谓的状态，其实指的是 Flink 程序的中间计算结果。Flink 支持了不同类型的状态，并且针对状态的持久化还提供了专门的机制和状态管理器。</p>
<h2 id="状态">状态</h2>
<p>我们在 Flink 的官方博客中找到这样一段话，可以认为这是对状态的定义：</p>
<blockquote>
<p>When working with state, it might also be useful to read about Flink’s state backends. Flink provides different state backends that specify how and where state is stored. State can be located on Java’s heap or off-heap. Depending on your state backend, Flink can also manage the state for the application, meaning Flink deals with the memory management (possibly spilling to disk if necessary) to allow applications to hold very large state. State backends can be configured without changing your application logic.</p>
</blockquote>
<p>这段话告诉我们，所谓的状态指的是，在流处理过程中那些需要记住的数据，而这些数据既可以包括业务数据，也可以包括元数据。Flink 本身提供了不同的状态管理器来管理状态，并且这个状态可以非常大。</p>
<p>Flink 的状态数据可以存在 JVM 的堆内存或者堆外内存中，当然也可以借助第三方存储，例如 Flink 已经实现的对 RocksDB 支持。Flink 的官网同样给出了适用于状态计算的几种情况：</p>
<ul>
<li>When an application searches for certain event patterns, the state will store the sequence of events encountered so far</li>
<li>When aggregating events per minute/hour/day, the state holds the pending aggregates</li>
<li>When training a machine learning model over a stream of data points, the state holds the current version of the model parameters</li>
<li>When historic data needs to be managed, the state allows efficient access to events that occurred in the past</li>
</ul>
<p>以上四种情况分别是：复杂事件处理获取符合某一特定时间规则的事件、聚合计算、机器学习的模型训练、使用历史的数据进行计算。</p>
<h2 id="flink-状态分类和使用">Flink 状态分类和使用</h2>
<p>我们在之前的课时中提到过 KeyedStream 的概念，并且介绍过 KeyBy 这个算子的使用。在 Flink 中，根据数据集是否按照某一个 Key 进行分区，将状态分为 <strong>Keyed State</strong> 和 <strong>Operator State</strong>（Non-Keyed State）两种类型。</p>
<p><figure><img src="/images/ring.svg" data-src="/images/KeyedStream.png" data-sizes="auto" alt="KeyedStream" title="KeyedStream" class="lazyload"><figcaption class="image-caption">KeyedStream</figcaption></figure></p>
<p>如上图所示，Keyed State 是经过分区后的流上状态，每个 Key 都有自己的状态，图中的八边形、圆形和三角形分别管理各自的状态，并且只有指定的 key 才能访问和更新自己对应的状态。</p>
<p>与 Keyed State 不同的是，Operator State 可以用在所有算子上，每个算子子任务或者说每个算子实例共享一个状态，流入这个算子子任务的数据可以访问和更新这个状态。每个算子子任务上的数据共享自己的状态。</p>
<p>但是有一点需要说明的是，无论是 Keyed State 还是 Operator State，Flink 的状态都是基于本地的，即每个算子子任务维护着这个算子子任务对应的状态存储，算子子任务之间的状态不能相互访问。</p>
<p><figure><img src="/images/ring.svg" data-src="/images/%E7%9B%B8%E4%BA%92%E8%AE%BF%E9%97%AE.png" data-sizes="auto" alt="相互访问" title="相互访问" class="lazyload"><figcaption class="image-caption">相互访问</figcaption></figure></p>
<p>我们可以看一下 State 的类图，对于 Keyed State，Flink 提供了几种现成的数据结构供我们使用，State 主要有四种实现，分别为 ValueState、MapState、AppendingState 和 ReadOnlyBrodcastState ，其中 AppendingState 又可以细分为 ReducingState、AggregatingState 和 ListState。</p>
<p>那么我们怎么访问这些状态呢？Flink 提供了 StateDesciptor 方法专门用来访问不同的 state，类图如下：</p>
<p><figure><img src="/images/ring.svg" data-src="/images/%E7%B1%BB%E5%9B%BE2.png" data-sizes="auto" alt="类图2" title="类图2" class="lazyload"><figcaption class="image-caption">类图2</figcaption></figure></p>
<p>下面演示一下如何使用 StateDesciptor 和 ValueState，代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>

   <span style="color:#66d9ef">final</span> StreamExecutionEnvironment env <span style="color:#f92672">=</span> StreamExecutionEnvironment<span style="color:#f92672">.</span><span style="color:#a6e22e">getExecutionEnvironment</span><span style="color:#f92672">();</span>

   env<span style="color:#f92672">.</span><span style="color:#a6e22e">fromElements</span><span style="color:#f92672">(</span>Tuple2<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> 3L<span style="color:#f92672">),</span> Tuple2<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> 5L<span style="color:#f92672">),</span> Tuple2<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> 7L<span style="color:#f92672">),</span> Tuple2<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> 5L<span style="color:#f92672">),</span> Tuple2<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>1L<span style="color:#f92672">,</span> 2L<span style="color:#f92672">))</span>
         <span style="color:#f92672">.</span><span style="color:#a6e22e">keyBy</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
         <span style="color:#f92672">.</span><span style="color:#a6e22e">flatMap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> CountWindowAverage<span style="color:#f92672">())</span>
         <span style="color:#f92672">.</span><span style="color:#a6e22e">printToErr</span><span style="color:#f92672">();</span>

       env<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;submit job&#34;</span><span style="color:#f92672">);</span>

<span style="color:#f92672">}</span>


   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CountWindowAverage</span> <span style="color:#66d9ef">extends</span> RichFlatMapFunction<span style="color:#f92672">&lt;</span>Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;,</span> Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">{</span>

       <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> ValueState<span style="color:#f92672">&lt;</span>Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;&gt;</span> sum<span style="color:#f92672">;</span>
       <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flatMap</span><span style="color:#f92672">(</span>Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;</span> input<span style="color:#f92672">,</span> Collector<span style="color:#f92672">&lt;</span>Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;&gt;</span> out<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>

           Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;</span> currentSum<span style="color:#f92672">;</span>
           <span style="color:#75715e">// 访问ValueState
</span><span style="color:#75715e"></span>           <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>sum<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">()==</span><span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
               currentSum <span style="color:#f92672">=</span> Tuple2<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>0L<span style="color:#f92672">,</span> 0L<span style="color:#f92672">);</span>
           <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
               currentSum <span style="color:#f92672">=</span> sum<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">();</span>
           <span style="color:#f92672">}</span>

           <span style="color:#75715e">// 更新
</span><span style="color:#75715e"></span>           currentSum<span style="color:#f92672">.</span><span style="color:#a6e22e">f0</span> <span style="color:#f92672">+=</span> 1<span style="color:#f92672">;</span>

           <span style="color:#75715e">// 第二个元素加1
</span><span style="color:#75715e"></span>           currentSum<span style="color:#f92672">.</span><span style="color:#a6e22e">f1</span> <span style="color:#f92672">+=</span> input<span style="color:#f92672">.</span><span style="color:#a6e22e">f1</span><span style="color:#f92672">;</span>

           <span style="color:#75715e">// 更新state
</span><span style="color:#75715e"></span>           sum<span style="color:#f92672">.</span><span style="color:#a6e22e">update</span><span style="color:#f92672">(</span>currentSum<span style="color:#f92672">);</span>

           <span style="color:#75715e">// 如果count的值大于等于2，求知道并清空state
</span><span style="color:#75715e"></span>           <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>currentSum<span style="color:#f92672">.</span><span style="color:#a6e22e">f0</span> <span style="color:#f92672">&gt;=</span> 2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
               out<span style="color:#f92672">.</span><span style="color:#a6e22e">collect</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Tuple2<span style="color:#f92672">&lt;&gt;(</span>input<span style="color:#f92672">.</span><span style="color:#a6e22e">f0</span><span style="color:#f92672">,</span> currentSum<span style="color:#f92672">.</span><span style="color:#a6e22e">f1</span> <span style="color:#f92672">/</span> currentSum<span style="color:#f92672">.</span><span style="color:#a6e22e">f0</span><span style="color:#f92672">));</span>
               sum<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
           <span style="color:#f92672">}</span>
   <span style="color:#f92672">}</span>


   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">open</span><span style="color:#f92672">(</span>Configuration config<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
       ValueStateDescriptor<span style="color:#f92672">&lt;</span>Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;&gt;</span> descriptor <span style="color:#f92672">=</span>
               <span style="color:#66d9ef">new</span> ValueStateDescriptor<span style="color:#f92672">&lt;&gt;(</span>
                       <span style="color:#e6db74">&#34;average&#34;</span><span style="color:#f92672">,</span> <span style="color:#75715e">// state的名字
</span><span style="color:#75715e"></span>                       TypeInformation<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> TypeHint<span style="color:#f92672">&lt;</span>Tuple2<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">,</span> Long<span style="color:#f92672">&gt;&gt;()</span> <span style="color:#f92672">{})</span>
                       <span style="color:#f92672">);</span> <span style="color:#75715e">// 设置默认值
</span><span style="color:#75715e"></span>

       StateTtlConfig ttlConfig <span style="color:#f92672">=</span> StateTtlConfig
               <span style="color:#f92672">.</span><span style="color:#a6e22e">newBuilder</span><span style="color:#f92672">(</span>Time<span style="color:#f92672">.</span><span style="color:#a6e22e">seconds</span><span style="color:#f92672">(</span>10<span style="color:#f92672">))</span>
               <span style="color:#f92672">.</span><span style="color:#a6e22e">setUpdateType</span><span style="color:#f92672">(</span>StateTtlConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">UpdateType</span><span style="color:#f92672">.</span><span style="color:#a6e22e">OnCreateAndWrite</span><span style="color:#f92672">)</span>
               <span style="color:#f92672">.</span><span style="color:#a6e22e">setStateVisibility</span><span style="color:#f92672">(</span>StateTtlConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">StateVisibility</span><span style="color:#f92672">.</span><span style="color:#a6e22e">NeverReturnExpired</span><span style="color:#f92672">)</span>
               <span style="color:#f92672">.</span><span style="color:#a6e22e">build</span><span style="color:#f92672">();</span>

       descriptor<span style="color:#f92672">.</span><span style="color:#a6e22e">enableTimeToLive</span><span style="color:#f92672">(</span>ttlConfig<span style="color:#f92672">);</span>

       sum <span style="color:#f92672">=</span> getRuntimeContext<span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">(</span>descriptor<span style="color:#f92672">);</span>
       <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在上述例子中，我们通过继承 RichFlatMapFunction 来访问 State，通过 getRuntimeContext().getState(descriptor) 来获取状态的句柄。而真正的访问和更新状态则在 Map 函数中实现。</p>
<p>我们这里的输出条件为，每当第一个元素的和达到二，就把第二个元素的和与第一个元素的和相除，最后输出。我们直接运行，在控制台可以看到结果：</p>
<p><figure><img src="/images/ring.svg" data-src="/images/%E7%9C%8B%E5%88%B0%E7%BB%93%E6%9E%9C.png" data-sizes="auto" alt="看到结果" title="看到结果" class="lazyload"><figcaption class="image-caption">看到结果</figcaption></figure></p>
<p>Operator State 的实际应用场景不如 Keyed State 多，一般来说它会被用在 Source 或 Sink 等算子上，用来保存流入数据的偏移量或对输出数据做缓存，以保证 Flink 应用的 Exactly-Once 语义。</p>
<p>同样，我们对于任何状态数据还可以设置它们的过期时间。如果一个状态设置了 TTL，并且已经过期，那么我们之前保存的值就会被清理。</p>
<p>想要使用 TTL，我们需要首先构建一个 StateTtlConfig 配置对象；然后，可以通过传递配置在任何状态描述符中启用 TTL 功能。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">StateTtlConfig ttlConfig <span style="color:#f92672">=</span> StateTtlConfig
        <span style="color:#f92672">.</span><span style="color:#a6e22e">newBuilder</span><span style="color:#f92672">(</span>Time<span style="color:#f92672">.</span><span style="color:#a6e22e">seconds</span><span style="color:#f92672">(</span>10<span style="color:#f92672">))</span>
        <span style="color:#f92672">.</span><span style="color:#a6e22e">setUpdateType</span><span style="color:#f92672">(</span>StateTtlConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">UpdateType</span><span style="color:#f92672">.</span><span style="color:#a6e22e">OnCreateAndWrite</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">.</span><span style="color:#a6e22e">setStateVisibility</span><span style="color:#f92672">(</span>StateTtlConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">StateVisibility</span><span style="color:#f92672">.</span><span style="color:#a6e22e">NeverReturnExpired</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">.</span><span style="color:#a6e22e">build</span><span style="color:#f92672">();</span>

descriptor<span style="color:#f92672">.</span><span style="color:#a6e22e">enableTimeToLive</span><span style="color:#f92672">(</span>ttlConfig<span style="color:#f92672">);</span>
</code></pre></div><p><figure><img src="/images/ring.svg" data-src="/images/TTL.png" data-sizes="auto" alt="TTL" title="TTL" class="lazyload"><figcaption class="image-caption">TTL</figcaption></figure></p>
<p>StateTtlConfig 这个类中有一些配置需要我们注意：</p>
<p><figure><img src="/images/ring.svg" data-src="/images/StateTtlConfig.png" data-sizes="auto" alt="StateTtlConfig" title="StateTtlConfig" class="lazyload"><figcaption class="image-caption">StateTtlConfig</figcaption></figure></p>
<p>UpdateType 表明了过期时间什么时候更新，而对于那些过期的状态，是否还能被访问则取决于 StateVisibility 的配置。</p>
<h2 id="状态后端种类和配置">状态后端种类和配置</h2>
<p>我们在上面的内容中讲到了 Flink 的状态数据可以存在 JVM 的堆内存或者堆外内存中，当然也可以借助第三方存储。默认情况下，Flink 的状态会保存在 taskmanager 的内存中，Flink 提供了三种可用的状态后端用于在不同情况下进行状态后端的保存。</p>
<ul>
<li>MemoryStateBackend</li>
<li>FsStateBackend</li>
<li>RocksDBStateBackend</li>
</ul>
<h3 id="memorystatebackend">MemoryStateBackend</h3>
<p>顾名思义，MemoryStateBackend 将 state 数据存储在内存中，一般用来进行本地调试用，我们在使用 MemoryStateBackend 时需要注意的一些点包括：</p>
<blockquote>
<p>每个独立的状态（state）默认限制大小为 5MB，可以通过构造函数增加容量<br>
状态的大小不能超过 akka 的 Framesize 大小<br>
聚合后的状态必须能够放进 JobManager 的内存中</p>
</blockquote>
<p>MemoryStateBackend 可以通过在代码中显示指定：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> StreamExecutionEnvironment env <span style="color:#f92672">=</span> StreamExecutionEnvironment<span style="color:#f92672">.</span><span style="color:#a6e22e">getExecutionEnvironment</span><span style="color:#f92672">();</span>
env<span style="color:#f92672">.</span><span style="color:#a6e22e">setStateBackend</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MemoryStateBackend<span style="color:#f92672">(</span>DEFAULT_MAX_STATE_SIZE<span style="color:#f92672">,</span><span style="color:#66d9ef">false</span><span style="color:#f92672">));</span>
</code></pre></div><p>其中，new MemoryStateBackend(DEFAULT_MAX_STATE_SIZE,false) 中的 false 代表关闭异步快照机制。关于快照，我们在后面的课时中有单独介绍。</p>
<p>很明显 MemoryStateBackend 适用于我们本地调试使用，来记录一些状态很小的 Job 状态信息。</p>
<h3 id="fsstatebackend">FsStateBackend</h3>
<p>FsStateBackend 会把状态数据保存在 TaskManager 的内存中。CheckPoint 时，将状态快照写入到配置的文件系统目录中，少量的元数据信息存储到 JobManager 的内存中。</p>
<p>使用 FsStateBackend 需要我们指定一个文件路径，一般来说是 HDFS 的路径，例如，hdfs://namenode:40010/flink/checkpoints。</p>
<p>我们同样可以在代码中显示指定：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> StreamExecutionEnvironment env <span style="color:#f92672">=</span> StreamExecutionEnvironment<span style="color:#f92672">.</span><span style="color:#a6e22e">getExecutionEnvironment</span><span style="color:#f92672">();</span>
env<span style="color:#f92672">.</span><span style="color:#a6e22e">setStateBackend</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FsStateBackend<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hdfs://namenode:40010/flink/checkpoints&#34;</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">));</span>
</code></pre></div><p>FsStateBackend 因为将状态存储在了外部系统如 HDFS 中，所以它适用于大作业、状态较大、全局高可用的那些任务。</p>
<h3 id="rocksdbstatebackend">RocksDBStateBackend</h3>
<p>RocksDBStateBackend 和 FsStateBackend 有一些类似，首先它们都需要一个外部文件存储路径，比如 HDFS 的 hdfs://namenode:40010/flink/checkpoints，此外也适用于大作业、状态较大、全局高可用的那些任务。</p>
<p>但是与 FsStateBackend 不同的是，RocksDBStateBackend 将正在运行中的状态数据保存在 RocksDB 数据库中，RocksDB 数据库默认将数据存储在 TaskManager 运行节点的数据目录下。</p>
<p>这意味着，RocksDBStateBackend 可以存储远超过 FsStateBackend 的状态，可以避免向 FsStateBackend 那样一旦出现状态暴增会导致 OOM，但是因为将状态数据保存在 RocksDB 数据库中，吞吐量会有所下降。</p>
<p>此外，需要注意的是，RocksDBStateBackend 是唯一支持增量快照的状态后端。</p>
<h2 id="总结">总结</h2>
<p>我们在这一课时中讲解了 Flink 中的状态分类和使用，并且用实际案例演示了用法；此外介绍了 Flink 状态的保存方式和优缺点。</p>
<p><a href="https://github.com/wangzhiwubigdata/quickstart">点击这里下载本课程源码</a>。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>追寻原风景 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-10/>https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-10/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://xiaohao890809.github.io/tags/42%E8%AE%B2%E8%BD%BB%E6%9D%BE%E9%80%9A%E5%85%B3flink/">
                    #42讲轻松通关Flink</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://xiaohao890809.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-09/" class="prev" rel="prev" title="第08讲：Flink 窗口、时间和水印"><i class="iconfont icon-left"></i>&nbsp;第08讲：Flink 窗口、时间和水印</a>
         
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-11/" class="next" rel="next" title="第10讲：Flink Side OutPut 分流">第10讲：Flink Side OutPut 分流&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
        
        
    </div>

</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2015 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://xiaohao890809.github.io">追寻原风景</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>













    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>

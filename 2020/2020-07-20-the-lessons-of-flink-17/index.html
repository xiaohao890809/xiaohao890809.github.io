<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="追寻原风景">
  
  
  
  <link rel="prev" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-16/" />
  <link rel="next" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-18/" />
  <link rel="canonical" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-17/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           第16讲：如何处理生产环境中的数据倾斜问题 | 枕霞惜友
       
  </title>
  <meta name="title" content="第16讲：如何处理生产环境中的数据倾斜问题 | 枕霞惜友">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xiaohao890809.github.io"
    },
    "articleSection" : "posts",
    "name" : "第16讲：如何处理生产环境中的数据倾斜问题",
    "headline" : "第16讲：如何处理生产环境中的数据倾斜问题",
    "description" : "这一课时我们主要讲解如何处理生产环境中的数据倾斜问题。\n无论是对于 Flink、Spark 这样的实时计算框架还是 Hive 等离线计算框架，数据量从来都不是问题，真正引起问题导致严重后果的是数据倾斜。所谓数据倾斜，是指在大规模并行处理的数据中，其中某个运行节点处理的数据远远超过其他部分，这会导致该节点压力极大，最终出现运行失败从而导致整个任务的失败。\n我们在这一课时中将分析出现数据倾斜的原因，Flink 任务中最容易出现数据倾斜的几个算子并且给出解决方案。\n数据倾斜背景和危害 数据倾斜产生的原因和危害和解决方案有哪些呢？我们一一来看。\n数据倾斜原理 目前我们所知道的大数据处理框架，比如 Flink、Spark、Hadoop 等之所以能处理高达千亿的数据，是因为这些框架都利用了分布式计算的思想，集群中多个计算节点并行，使得数据处理能力能得到线性扩展。\n我们在第 03 课时“Flink 的编程模型与其他框架比较”中曾经讲过，在实际生产中 Flink 都是以集群的形式在运行，在运行的过程中包含了两类进程。其中 TaskManager 实际负责执行计算的 Worker，在其上执行 Flink Job 的一组 Task，Task 则是我们执行具体代码逻辑的容器。理论上只要我们的任务 Task 足够多就可以对足够大的数据量进行处理。\n但是实际上大数据量经常出现，一个 Flink 作业包含 200 个 Task 节点，其中有 199 个节点可以在很短的时间内完成计算。但是有一个节点执行时间远超其他结果，并且随着数据量的持续增加，导致该计算节点挂掉，从而整个任务失败重启。我们可以在 Flink 的管理界面中看到任务的某一个 Task 数据量远超其他节点。\n数据倾斜原因和解决方案 Flink 任务出现数据倾斜的直观表现是任务节点频繁出现反压，但是增加并行度后并不能解决问题；部分节点出现 OOM 异常，是因为大量的数据集中在某个节点上，导致该节点内存被爆，任务失败重启。\n产生数据倾斜的原因主要有 2 个方面：\n 业务上有严重的数据热点，比如滴滴打车的订单数据中北京、上海等几个城市的订单量远远超过其他地区； 技术上大量使用了 KeyBy、GroupBy 等操作，错误的使用了分组 Key，人为产生数据热点。  因此解决问题的思路也很清晰：\n 业务上要尽量避免热点 key 的设计，例如我们可以把北京、上海等热点城市分成不同的区域，并进行单独处理； 技术上出现热点时，要调整方案打散原来的 key，避免直接聚合；此外 Flink 还提供了大量的功能可以避免数据倾斜。  那么我们就从典型的场景入手，看看在 Flink 任务中出现数据倾斜的主要场景和解决方案。",
    "inLanguage" : "en-us",
    "author" : "王知无",
    "creator" : "王知无",
    "publisher": "王知无",
    "accountablePerson" : "王知无",
    "copyrightHolder" : "王知无",
    "copyrightYear" : "2020",
    "datePublished": "2020-07-20 10:28:48 \u002b0000 UTC",
    "dateModified" : "2020-07-20 10:28:48 \u002b0000 UTC",
    "url" : "https:\/\/xiaohao890809.github.io\/2020\/2020-07-20-the-lessons-of-flink-17\/",
    "wordCount" : "452",
    "keywords" : [ "42讲轻松通关Flink", "枕霞惜友"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <div class="top-scroll-bar"></div>
    
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">第16讲：如何处理生产环境中的数据倾斜问题</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xiaohao890809.github.io" rel="author">王知无</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-07-20 itemprop="datePublished">July 20, 2020</time>
                </span>
                
        </div>
    </header>

    
          <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title"></h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#数据倾斜背景和危害">数据倾斜背景和危害</a>
      <ul>
        <li><a href="#数据倾斜原理">数据倾斜原理</a></li>
        <li><a href="#数据倾斜原因和解决方案">数据倾斜原因和解决方案</a></li>
      </ul>
    </li>
    <li><a href="#flink-任务数据倾斜场景和解决方案">Flink 任务数据倾斜场景和解决方案</a>
      <ul>
        <li><a href="#两阶段聚合解决-keyby-热点">两阶段聚合解决 KeyBy 热点</a></li>
        <li><a href="#groupby--aggregation-分组聚合热点问题">GroupBy + Aggregation 分组聚合热点问题</a></li>
        <li><a href="#flink-消费-kafka-上下游并行度不一致导致的数据倾斜">Flink 消费 Kafka 上下游并行度不一致导致的数据倾斜</a></li>
        <li><a href="#其他">其他</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>
<script type="text/javascript">
  window.onload = function () {
    var fix = $('.post-toc');
    var end = $('.post-comment');
    var fixTop = fix.offset().top, fixHeight = fix.height();
    var endTop, miss;
    var offsetTop = fix[0].offsetTop;
    $(window).scroll(function () {
      var docTop = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
      if (end.length > 0) {
        endTop = end.offset().top;
        miss = endTop - docTop - fixHeight;
      }
      if (fixTop < docTop) {
        fix.css({ 'position': 'fixed' });
        if ((end.length > 0) && (endTop < (docTop + fixHeight))) {
          fix.css({ top: miss });
        } else {
          fix.css({ top: 0 });
        }
      } else {
        fix.css({ 'position': 'absolute' });
        fix.css({ top: offsetTop });
      }
    })
  }
</script> 
    

    <script type="text/javascript">
            window.MathJax = {
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            TeX: {equationNumbers: {autoNumber: "AMS"}},
            showProcessingMessages: false,
            messageStyle: 'none'
        };
   </script>

    <script type="text/javascript" async src="/lib/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>

    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <p>这一课时我们主要讲解如何处理生产环境中的数据倾斜问题。</p>
<p>无论是对于 Flink、Spark 这样的实时计算框架还是 Hive 等离线计算框架，数据量从来都不是问题，真正引起问题导致严重后果的是<strong>数据倾斜</strong>。所谓数据倾斜，是指在大规模并行处理的数据中，其中某个运行节点处理的数据远远超过其他部分，这会导致该节点压力极大，最终出现运行失败从而导致整个任务的失败。</p>
<p>我们在这一课时中将分析出现数据倾斜的原因，Flink 任务中最容易出现数据倾斜的几个算子并且给出解决方案。</p>
<h2 id="数据倾斜背景和危害">数据倾斜背景和危害</h2>
<p>数据倾斜产生的原因和危害和解决方案有哪些呢？我们一一来看。</p>
<h3 id="数据倾斜原理">数据倾斜原理</h3>
<p>目前我们所知道的大数据处理框架，比如 Flink、Spark、Hadoop 等之所以能处理高达千亿的数据，是因为这些框架都利用了分布式计算的思想，集群中多个计算节点并行，使得数据处理能力能得到线性扩展。</p>
<p>我们在第 03 课时“Flink 的编程模型与其他框架比较”中曾经讲过，在实际生产中 Flink 都是以集群的形式在运行，在运行的过程中包含了两类进程。其中 TaskManager 实际负责执行计算的 Worker，在其上执行 Flink Job 的一组 Task，Task 则是我们执行具体代码逻辑的容器。理论上只要我们的任务 Task 足够多就可以对足够大的数据量进行处理。</p>
<p>但是实际上大数据量经常出现，一个 Flink 作业包含 200 个 Task 节点，其中有 199 个节点可以在很短的时间内完成计算。但是有一个节点执行时间远超其他结果，并且随着数据量的持续增加，导致该计算节点挂掉，从而整个任务失败重启。我们可以在 Flink 的管理界面中看到任务的某一个 Task 数据量远超其他节点。</p>
<h3 id="数据倾斜原因和解决方案">数据倾斜原因和解决方案</h3>
<p>Flink 任务出现数据倾斜的直观表现是任务节点频繁出现反压，但是增加并行度后并不能解决问题；部分节点出现 OOM 异常，是因为大量的数据集中在某个节点上，导致该节点内存被爆，任务失败重启。</p>
<p>产生数据倾斜的原因主要有 2 个方面：</p>
<ul>
<li>业务上有严重的数据热点，比如滴滴打车的订单数据中北京、上海等几个城市的订单量远远超过其他地区；</li>
<li>技术上大量使用了 KeyBy、GroupBy 等操作，错误的使用了分组 Key，人为产生数据热点。</li>
</ul>
<p>因此解决问题的思路也很清晰：</p>
<ul>
<li>业务上要尽量避免热点 key 的设计，例如我们可以把北京、上海等热点城市分成不同的区域，并进行单独处理；</li>
<li>技术上出现热点时，要调整方案打散原来的 key，避免直接聚合；此外 Flink 还提供了大量的功能可以避免数据倾斜。</li>
</ul>
<p>那么我们就从典型的场景入手，看看在 Flink 任务中出现数据倾斜的主要场景和解决方案。</p>
<h2 id="flink-任务数据倾斜场景和解决方案">Flink 任务数据倾斜场景和解决方案</h2>
<h3 id="两阶段聚合解决-keyby-热点">两阶段聚合解决 KeyBy 热点</h3>
<p>KeyBy 是我们经常使用的分组聚合函数之一。在实际的业务中经常会碰到这样的场景：双十一按照下单用户所在的省聚合求订单量最高的前 10 个省，或者按照用户的手机类型聚合求访问量最高的设备类型等。</p>
<p>上述场景在我们进行 KeyBy 时就会出现严重的数据倾斜，如下图所示：</p>
<p><figure><img src="/images/ring.svg" data-src="/images/KeyBy.png" data-sizes="auto" alt="KeyBy" title="KeyBy" class="lazyload"><figcaption class="image-caption">KeyBy</figcaption></figure></p>
<p>如果我们直接简单地使用 KeyBy 算子，模拟一个简单的统计 PV 的场景如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">DataStream sourceStream <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>
windowedStream <span style="color:#f92672">=</span> sourceStream<span style="color:#f92672">.</span><span style="color:#a6e22e">keyBy</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;type&#34;</span><span style="color:#f92672">)</span>
          <span style="color:#f92672">.</span><span style="color:#a6e22e">window</span><span style="color:#f92672">(</span>TumblingEventTimeWindows<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>Time<span style="color:#f92672">.</span><span style="color:#a6e22e">minutes</span><span style="color:#f92672">(</span>1<span style="color:#f92672">)));</span>
windowedStream<span style="color:#f92672">.</span><span style="color:#a6e22e">process</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MyPVFunction<span style="color:#f92672">())</span>
              <span style="color:#f92672">.</span><span style="color:#a6e22e">addSink</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> MySink<span style="color:#f92672">())...</span> 
env<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">()...</span>
</code></pre></div><p>我们在根据 type 进行 KeyBy 时，如果数据的 type 分布不均匀就会导致大量的数据分配到一个 task 中去，发生数据倾斜。
那么我们的解决思路是：</p>
<ul>
<li>首先把分组的 key 打散，比如加随机后缀；</li>
<li>对打散后的数据进行聚合；</li>
<li>把打散的 key 还原为真正的 key；</li>
<li>二次 KeyBy 进行结果统计，然后输出。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">DataStream sourceStream <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>
resultStream <span style="color:#f92672">=</span> sourceStream
     <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>record <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
        Record record <span style="color:#f92672">=</span> JSON<span style="color:#f92672">.</span><span style="color:#a6e22e">parseObject</span><span style="color:#f92672">(</span>record<span style="color:#f92672">,</span> Record<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
        String type <span style="color:#f92672">=</span> record<span style="color:#f92672">.</span><span style="color:#a6e22e">getType</span><span style="color:#f92672">();</span>
        record<span style="color:#f92672">.</span><span style="color:#a6e22e">setType</span><span style="color:#f92672">(</span>type <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;#&#34;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">new</span> Random<span style="color:#f92672">().</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">(</span>100<span style="color:#f92672">));</span>
        <span style="color:#66d9ef">return</span> record<span style="color:#f92672">;</span>
      <span style="color:#f92672">})</span>
      <span style="color:#f92672">.</span><span style="color:#a6e22e">keyBy</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
      <span style="color:#f92672">.</span><span style="color:#a6e22e">window</span><span style="color:#f92672">(</span>TumblingEventTimeWindows<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span>Time<span style="color:#f92672">.</span><span style="color:#a6e22e">minutes</span><span style="color:#f92672">(</span>1<span style="color:#f92672">)))</span>
      <span style="color:#f92672">.</span><span style="color:#a6e22e">aggregate</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> CountAggregate<span style="color:#f92672">())</span>
      <span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>count <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
        String key <span style="color:#f92672">=</span> count<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">.</span><span style="color:#a6e22e">substring</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> count<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">.</span><span style="color:#a6e22e">indexOf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;#&#34;</span><span style="color:#f92672">));</span>
        <span style="color:#66d9ef">return</span> RecordCount<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span>count<span style="color:#f92672">.</span><span style="color:#a6e22e">getCount</span><span style="color:#f92672">);</span>
      <span style="color:#f92672">})</span>
      <span style="color:#75715e">//二次聚合
</span><span style="color:#75715e"></span>      <span style="color:#f92672">.</span><span style="color:#a6e22e">keyBy</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
      <span style="color:#f92672">.</span><span style="color:#a6e22e">process</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> CountProcessFunction<span style="color:#f92672">);</span>

resultStream<span style="color:#f92672">.</span><span style="color:#a6e22e">sink</span><span style="color:#f92672">()...</span>
env<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">()...</span>
</code></pre></div><p>其中 CountAggregate 函数实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CountAggregate</span> <span style="color:#66d9ef">implements</span> AggregateFunction<span style="color:#f92672">&lt;</span>Record<span style="color:#f92672">,</span>CountRecord<span style="color:#f92672">,</span>CountRecord<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> CountRecord <span style="color:#a6e22e">createAccumulator</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CountRecord<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> 0L<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> CountRecord <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>Record value<span style="color:#f92672">,</span> CountRecord accumulator<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>accumulator<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            accumulator<span style="color:#f92672">.</span><span style="color:#a6e22e">setKey</span><span style="color:#f92672">(</span>value<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        accumulator<span style="color:#f92672">.</span><span style="color:#a6e22e">setCount</span><span style="color:#f92672">(</span>value<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> accumulator<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> CountRecord <span style="color:#a6e22e">getResult</span><span style="color:#f92672">(</span>CountRecord accumulator<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> accumulator<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> CountRecord <span style="color:#a6e22e">merge</span><span style="color:#f92672">(</span>CountRecord a<span style="color:#f92672">,</span> CountRecord b<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CountRecord<span style="color:#f92672">(</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">(),</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">getCount</span><span style="color:#f92672">()+</span>b<span style="color:#f92672">.</span><span style="color:#a6e22e">getCount</span><span style="color:#f92672">())</span> <span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>CountProcessFunction 的实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CountProcessFunction</span> <span style="color:#66d9ef">extends</span> KeyedProcessFunction<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> CountRecord<span style="color:#f92672">,</span> CountRecord<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> ValueState<span style="color:#f92672">&lt;</span>Long<span style="color:#f92672">&gt;</span> state <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getRuntimeContext</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getState</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ValueStateDescriptor<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;count&#34;</span><span style="color:#f92672">,</span>Long<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">));</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processElement</span><span style="color:#f92672">(</span>CountRecord value<span style="color:#f92672">,</span> Context ctx<span style="color:#f92672">,</span> Collector<span style="color:#f92672">&lt;</span>CountRecord<span style="color:#f92672">&gt;</span> out<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>state<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">()==</span>0<span style="color:#f92672">){</span>
            state<span style="color:#f92672">.</span><span style="color:#a6e22e">update</span><span style="color:#f92672">(</span>value<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">);</span>
            ctx<span style="color:#f92672">.</span><span style="color:#a6e22e">timerService</span><span style="color:#f92672">().</span><span style="color:#a6e22e">registerProcessingTimeTimer</span><span style="color:#f92672">(</span>ctx<span style="color:#f92672">.</span><span style="color:#a6e22e">timerService</span><span style="color:#f92672">().</span><span style="color:#a6e22e">currentProcessingTime</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> 1000L <span style="color:#f92672">*</span> 5<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
            state<span style="color:#f92672">.</span><span style="color:#a6e22e">update</span><span style="color:#f92672">(</span>state<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> value<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onTimer</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> timestamp<span style="color:#f92672">,</span> OnTimerContext ctx<span style="color:#f92672">,</span> Collector<span style="color:#f92672">&lt;</span>CountRecord<span style="color:#f92672">&gt;</span> out<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
        <span style="color:#75715e">//这里可以做业务操作，例如每 5 分钟将统计结果发送出去
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//out.collect(...);
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//清除状态
</span><span style="color:#75715e"></span>        state<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">//其他操作
</span><span style="color:#75715e"></span>        <span style="color:#f92672">...</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>通过上面打散聚合再二次聚合的方式，我们就可以实现热点 Key 的打散，消除数据倾斜。</p>
<h3 id="groupby--aggregation-分组聚合热点问题">GroupBy + Aggregation 分组聚合热点问题</h3>
<p>业务上通过 GroupBy 进行分组，然后紧跟一个 SUM、COUNT 等聚合操作是非常常见的。我们都知道 GroupBy 函数会根据 Key 进行分组，完全依赖 Key 的设计，如果 Key 出现热点，那么会导致巨大的 shuffle，相同 key 的数据会被发往同一个处理节点；如果某个 key 的数据量过大则会直接导致该节点成为计算瓶颈，引起反压。</p>
<p>我们还是按照上面的分组统计 PV 的场景，SQL 语句如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">select
      date<span style="color:#f92672">,</span>
      type<span style="color:#f92672">,</span>
      sum<span style="color:#f92672">(</span>count<span style="color:#f92672">)</span> as pv
from table
      group by
      date<span style="color:#f92672">,</span>
      type<span style="color:#f92672">;</span>
</code></pre></div><p>我们可以通过内外两层聚合的方式将 SQL 改写为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">select date<span style="color:#f92672">,</span>
       type<span style="color:#f92672">,</span>
       sum<span style="color:#f92672">(</span>pv<span style="color:#f92672">)</span> as pv
<span style="color:#a6e22e">from</span><span style="color:#f92672">(</span>
  select
        date<span style="color:#f92672">,</span>
        type<span style="color:#f92672">,</span>
        sum<span style="color:#f92672">(</span>count<span style="color:#f92672">)</span> as pv
  from table
        group by
        date<span style="color:#f92672">,</span>
        type<span style="color:#f92672">,</span>
        floor<span style="color:#f92672">(</span>rand<span style="color:#f92672">()*</span>100<span style="color:#f92672">)</span> <span style="color:#f92672">--</span>随机打散成100份 
    <span style="color:#f92672">)</span>
    group by 
    date<span style="color:#f92672">,</span>
    type<span style="color:#f92672">;</span>
</code></pre></div><p>在上面的 SQL 拆成了内外两层，第一层通过随机打散 100 份的方式减少数据热点，当然这个打散的方式可以根据业务灵活指定。</p>
<h3 id="flink-消费-kafka-上下游并行度不一致导致的数据倾斜">Flink 消费 Kafka 上下游并行度不一致导致的数据倾斜</h3>
<p>通常我们在使用 Flink 处理实时业务时，上游一般都是消息系统，Kafka 是使用最广泛的大数据消息系统。当使用 Flink 消费 Kafka 数据时，也会出现数据倾斜。</p>
<p>需要十分注意的是，我们 Flink 消费 Kafka 的数据时，是推荐上下游并行度保持一致，即 Kafka 的分区数等于 Flink Consumer 的并行度。</p>
<p>但是会有一种情况，为了加快数据的处理速度，来设置 Flink 消费者的并行度大于 Kafka 的分区数。如果你不做任何的设置则会导致部分 Flink Consumer 线程永远消费不到数据。</p>
<p>这时候你需要设置 Flink 的 Redistributing，也就是数据重分配。</p>
<p>Flink 提供了多达 8 种重分区策略，类图如下图所示：</p>
<p><figure><img src="/images/ring.svg" data-src="/images/%E9%87%8D%E5%88%86%E9%85%8D.png" data-sizes="auto" alt="重分配" title="重分配" class="lazyload"><figcaption class="image-caption">重分配</figcaption></figure></p>
<p>在我们接收到 Kafka 消息后，可以通过自定义数据分区策略来实现数据的负载均衡，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">dataStream
        <span style="color:#f92672">.</span><span style="color:#a6e22e">setParallelism</span><span style="color:#f92672">(</span>2<span style="color:#f92672">)</span>
        <span style="color:#75715e">// 采用REBALANCE分区策略重分区
</span><span style="color:#75715e"></span>        <span style="color:#f92672">.</span><span style="color:#a6e22e">rebalance</span><span style="color:#f92672">()</span> <span style="color:#75715e">//.rescale()
</span><span style="color:#75715e"></span>        <span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">()</span>
        <span style="color:#f92672">.</span><span style="color:#a6e22e">setParallelism</span><span style="color:#f92672">(</span>4<span style="color:#f92672">);</span>
</code></pre></div><p>其中，Rebalance 分区策略，数据会以 round-robin 的方式对数据进行再次分区，可以全局负载均衡。</p>
<p>Rescale 分区策略基于上下游的并行度，会将数据以循环的方式输出到下游的每个实例中。</p>
<h3 id="其他">其他</h3>
<p>Flink 一直在不断地迭代，不断出现各种各样的手段解决我们遇到的数据倾斜问题。例如，MiniBatch 微批处理手段等，需要我们开发者不断地去发现，并学习新的解决问题的办法。</p>
<h2 id="总结">总结</h2>
<p>这一课时我们介绍了数据倾斜的原理和常见的解决方案，数据倾斜问题是大数据开发者遇到的最普遍也是最头疼的问题之一，如何高效地发现和解决数据倾斜问题是一个大数据从业者技术能力的直接体现。</p>
<p><a href="https://github.com/wangzhiwubigdata/quickstart">点击这里下载本课程源码</a>。</p>
<p>如果是计算UV这种数据，需要distinct, 怎么解决数据倾斜呢？</p>
<blockquote>
<p>讲师回复：也是第一种方法，给你举个例子：SELECT day, SUM(cnt) total FROM ( SELECT day, MOD(buy_id, 1024), COUNT(DISTINCT buy_id) as cnt FROM T GROUP BY day, MOD(buy_id, 1024)) GROUP BY day</p>
</blockquote>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>追寻原风景 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-17/>https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-17/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://xiaohao890809.github.io/tags/42%E8%AE%B2%E8%BD%BB%E6%9D%BE%E9%80%9A%E5%85%B3flink/">
                    #42讲轻松通关Flink</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://xiaohao890809.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-16/" class="prev" rel="prev" title="第15讲：如何排查生产环境中的反压问题"><i class="iconfont icon-left"></i>&nbsp;第15讲：如何排查生产环境中的反压问题</a>
         
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-18/" class="next" rel="next" title="第17讲：生产环境中的并行度和资源设置">第17讲：生产环境中的并行度和资源设置&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
        
        
    </div>

</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2015 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://xiaohao890809.github.io">追寻原风景</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>













    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="追寻原风景">
  
  
  
  <link rel="prev" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-14/" />
  <link rel="next" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-16/" />
  <link rel="canonical" href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-15/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           第14讲：Flink Exactly-once 实现原理解析 | 枕霞惜友
       
  </title>
  <meta name="title" content="第14讲：Flink Exactly-once 实现原理解析 | 枕霞惜友">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xiaohao890809.github.io"
    },
    "articleSection" : "posts",
    "name" : "第14讲：Flink Exactly-once 实现原理解析",
    "headline" : "第14讲：Flink Exactly-once 实现原理解析",
    "description" : "这一课时我们将讲解 Flink “精确一次”的语义实现原理，同时这也是面试的必考点。\nFlink 的“精确一次”处理语义是，Flink 提供了一个强大的语义保证，也就是说在任何情况下都能保证数据对应用产生的效果只有一次，不会多也不会少。\n那么 Flink 是如何实现“端到端的精确一次处理”语义的呢？\n背景 通常情况下，流式计算系统都会为用户提供指定数据处理的可靠模式功能，用来表明在实际生产运行中会对数据处理做哪些保障。一般来说，流处理引擎通常为用户的应用程序提供三种数据处理语义：最多一次、至少一次和精确一次。\n 最多一次（At-most-Once）：这种语义理解起来很简单，用户的数据只会被处理一次，不管成功还是失败，不会重试也不会重发。 至少一次（At-least-Once）：这种语义下，系统会保证数据或事件至少被处理一次。如果中间发生错误或者丢失，那么会从源头重新发送一条然后进入处理系统，所以同一个事件或者消息会被处理多次。 精确一次（Exactly-Once）：表示每一条数据只会被精确地处理一次，不多也不少。  Exactly-Once 是 Flink、Spark 等流处理系统的核心特性之一，这种语义会保证每一条消息只被流处理系统处理一次。“精确一次” 语义是 Flink 1.4.0 版本引入的一个重要特性，而且，Flink 号称支持“端到端的精确一次”语义。\n在这里我们解释一下“端到端（End to End）的精确一次”，它指的是 Flink 应用从 Source 端开始到 Sink 端结束，数据必须经过的起始点和结束点。Flink 自身是无法保证外部系统“精确一次”语义的，所以 Flink 若要实现所谓“端到端（End to End）的精确一次”的要求，那么外部系统必须支持“精确一次”语义；然后借助 Flink 提供的分布式快照和两阶段提交才能实现。\n分布式快照机制 我们在之前的课程中讲解过 Flink 的容错机制，Flink 提供了失败恢复的容错机制，而这个容错机制的核心就是持续创建分布式数据流的快照来实现。\n同 Spark 相比，Spark 仅仅是针对 Driver 的故障恢复 Checkpoint。而 Flink 的快照可以到算子级别，并且对全局数据也可以做快照。Flink 的分布式快照受到 Chandy-Lamport 分布式快照算法启发，同时进行了量身定做，有兴趣的同学可以搜一下。\nBarrier Flink 分布式快照的核心元素之一是 Barrier（数据栅栏），我们也可以把 Barrier 简单地理解成一个标记，该标记是严格有序的，并且随着数据流往下流动。每个 Barrier 都带有自己的 ID，Barrier 极其轻量，并不会干扰正常的数据处理。\n如上图所示，假如我们有一个从左向右流动的数据流，Flink 会依次生成 snapshot 1、 snapshot 2、snapshot 3……Flink 中有一个专门的“协调者”负责收集每个 snapshot 的位置信息，这个“协调者”也是高可用的。",
    "inLanguage" : "en-us",
    "author" : "王知无",
    "creator" : "王知无",
    "publisher": "王知无",
    "accountablePerson" : "王知无",
    "copyrightHolder" : "王知无",
    "copyrightYear" : "2020",
    "datePublished": "2020-07-20 10:26:48 \u002b0000 UTC",
    "dateModified" : "2020-07-20 10:26:48 \u002b0000 UTC",
    "url" : "https:\/\/xiaohao890809.github.io\/2020\/2020-07-20-the-lessons-of-flink-15\/",
    "wordCount" : "331",
    "keywords" : [ "42讲轻松通关Flink", "枕霞惜友"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <div class="top-scroll-bar"></div>
    
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xiaohao890809.github.io">枕霞惜友</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">第14讲：Flink Exactly-once 实现原理解析</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xiaohao890809.github.io" rel="author">王知无</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-07-20 itemprop="datePublished">July 20, 2020</time>
                </span>
                
        </div>
    </header>

    
          <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title"></h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#背景">背景</a></li>
    <li><a href="#分布式快照机制">分布式快照机制</a>
      <ul>
        <li><a href="#barrier">Barrier</a></li>
        <li><a href="#异步和增量">异步和增量</a></li>
      </ul>
    </li>
    <li><a href="#两阶段提交">两阶段提交</a>
      <ul>
        <li><a href="#flink-kafka-exactly-once">Flink-Kafka Exactly-once</a></li>
        <li><a href="#现状">现状</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>
<script type="text/javascript">
  window.onload = function () {
    var fix = $('.post-toc');
    var end = $('.post-comment');
    var fixTop = fix.offset().top, fixHeight = fix.height();
    var endTop, miss;
    var offsetTop = fix[0].offsetTop;
    $(window).scroll(function () {
      var docTop = Math.max(document.body.scrollTop, document.documentElement.scrollTop);
      if (end.length > 0) {
        endTop = end.offset().top;
        miss = endTop - docTop - fixHeight;
      }
      if (fixTop < docTop) {
        fix.css({ 'position': 'fixed' });
        if ((end.length > 0) && (endTop < (docTop + fixHeight))) {
          fix.css({ top: miss });
        } else {
          fix.css({ top: 0 });
        }
      } else {
        fix.css({ 'position': 'absolute' });
        fix.css({ top: offsetTop });
      }
    })
  }
</script> 
    

    <script type="text/javascript">
            window.MathJax = {
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            TeX: {equationNumbers: {autoNumber: "AMS"}},
            showProcessingMessages: false,
            messageStyle: 'none'
        };
   </script>

    <script type="text/javascript" async src="/lib/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>

    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <p>这一课时我们将讲解 Flink “精确一次”的语义实现原理，同时这也是面试的必考点。</p>
<p>Flink 的“精确一次”处理语义是，Flink 提供了一个强大的语义保证，也就是说在任何情况下都能保证数据对应用产生的效果只有一次，不会多也不会少。</p>
<p>那么 Flink 是如何实现“端到端的精确一次处理”语义的呢？</p>
<h2 id="背景">背景</h2>
<p>通常情况下，流式计算系统都会为用户提供指定数据处理的可靠模式功能，用来表明在实际生产运行中会对数据处理做哪些保障。一般来说，流处理引擎通常为用户的应用程序提供三种数据处理语义：最多一次、至少一次和精确一次。</p>
<ul>
<li><strong>最多一次（At-most-Once）</strong>：这种语义理解起来很简单，用户的数据只会被处理一次，不管成功还是失败，不会重试也不会重发。</li>
<li><strong>至少一次（At-least-Once）</strong>：这种语义下，系统会保证数据或事件至少被处理一次。如果中间发生错误或者丢失，那么会从源头重新发送一条然后进入处理系统，所以同一个事件或者消息会被处理多次。</li>
<li><strong>精确一次（Exactly-Once）</strong>：表示每一条数据只会被精确地处理一次，不多也不少。</li>
</ul>
<p>Exactly-Once 是 Flink、Spark 等流处理系统的核心特性之一，这种语义会保证每一条消息只被流处理系统处理一次。“精确一次” 语义是 Flink 1.4.0 版本引入的一个重要特性，而且，Flink 号称支持“端到端的精确一次”语义。</p>
<p>在这里我们解释一下“端到端（End to End）的精确一次”，它指的是 Flink 应用从 Source 端开始到 Sink 端结束，数据必须经过的起始点和结束点。Flink 自身是无法保证外部系统“精确一次”语义的，所以 Flink 若要实现所谓“端到端（End to End）的精确一次”的要求，那么外部系统必须支持“精确一次”语义；然后借助 Flink 提供的分布式快照和两阶段提交才能实现。</p>
<h2 id="分布式快照机制">分布式快照机制</h2>
<p>我们在之前的课程中讲解过 Flink 的容错机制，Flink 提供了失败恢复的容错机制，而这个容错机制的核心就是持续创建分布式数据流的快照来实现。</p>
<p>同 Spark 相比，Spark 仅仅是针对 Driver 的故障恢复 Checkpoint。而 Flink 的快照可以到算子级别，并且对全局数据也可以做快照。Flink 的分布式快照受到  Chandy-Lamport 分布式快照算法启发，同时进行了量身定做，有兴趣的同学可以搜一下。</p>
<h3 id="barrier">Barrier</h3>
<p>Flink 分布式快照的核心元素之一是 <strong>Barrier（数据栅栏）</strong>，我们也可以把 Barrier 简单地理解成一个标记，该标记是严格有序的，并且随着数据流往下流动。每个 Barrier 都带有自己的 ID，Barrier 极其轻量，并不会干扰正常的数据处理。</p>
<p><figure><img src="/images/ring.svg" data-src="/images/%E6%95%B0%E6%8D%AE%E6%A0%85%E6%A0%8F.png" data-sizes="auto" alt="数据栅栏" title="数据栅栏" class="lazyload"><figcaption class="image-caption">数据栅栏</figcaption></figure></p>
<p>如上图所示，假如我们有一个从左向右流动的数据流，Flink 会依次生成 snapshot 1、 snapshot 2、snapshot 3……Flink 中有一个专门的“协调者”负责收集每个 snapshot 的位置信息，这个“协调者”也是高可用的。</p>
<p>Barrier 会随着正常数据继续往下流动，每当遇到一个算子，算子会插入一个标识，这个标识的插入时间是上游所有的输入流都接收到 snapshot n。与此同时，当我们的 sink 算子接收到所有上游流发送的 Barrier 时，那么就表明这一批数据处理完毕，Flink 会向“协调者”发送确认消息，表明当前的 snapshot n 完成了。当所有的 sink 算子都确认这批数据成功处理后，那么本次的 snapshot 被标识为完成。</p>
<p>这里就会有一个问题，因为 Flink 运行在分布式环境中，一个 operator 的上游会有很多流，每个流的 barrier n 到达的时间不一致怎么办？这里 Flink 采取的措施是：<strong>快流等慢流</strong>。</p>
<p><figure><img src="/images/ring.svg" data-src="/images/%E5%BF%AB%E6%B5%81%E7%AD%89%E6%85%A2%E6%B5%81.png" data-sizes="auto" alt="快流等慢流" title="快流等慢流" class="lazyload"><figcaption class="image-caption">快流等慢流</figcaption></figure></p>
<blockquote>
<p>拿上图的 barrier n 来说，其中一个流到的早，其他的流到的比较晚。当第一个 barrier n到来后，当前的 operator 会继续等待其他流的 barrier n。直到所有的barrier n 到来后，operator 才会把所有的数据向下发送。</p>
</blockquote>
<h3 id="异步和增量">异步和增量</h3>
<p>按照上面我们介绍的机制，每次在把快照存储到我们的状态后端时，如果是同步进行就会阻塞正常任务，从而引入延迟。因此 Flink 在做快照存储时，可采用异步方式。</p>
<p>此外，由于 checkpoint 是一个全局状态，用户保存的状态可能非常大，多数达 G 或者 T 级别。在这种情况下，checkpoint 的创建会非常慢，而且执行时占用的资源也比较多，因此 Flink 提出了增量快照的概念。也就是说，每次都是进行的全量 checkpoint，是基于上次进行更新的。</p>
<h2 id="两阶段提交">两阶段提交</h2>
<p>上面我们讲解了基于 checkpoint 的快照操作，快照机制能够保证作业出现 fail-over 后可以从最新的快照进行恢复，即分布式快照机制可以保证 Flink 系统内部的“精确一次”处理。但是我们在实际生产系统中，Flink 会对接各种各样的外部系统，比如 Kafka、HDFS 等，一旦 Flink 作业出现失败，作业会重新消费旧数据，这时候就会出现重新消费的情况，也就是重复消费。</p>
<p>针对这种情况，Flink 1.4 版本引入了一个很重要的功能：两阶段提交，也就是 TwoPhaseCommitSinkFunction。两阶段搭配特定的 source 和 sink（特别是 0.11 版本 Kafka）使得“精确一次处理语义”成为可能。</p>
<p>在 Flink 中两阶段提交的实现方法被封装到了 TwoPhaseCommitSinkFunction 这个抽象类中，我们只需要实现其中的beginTransaction、preCommit、commit、abort 四个方法就可以实现“精确一次”的处理语义，实现的方式我们可以在官网中查到：</p>
<blockquote>
<p>beginTransaction，在开启事务之前，我们在目标文件系统的临时目录中创建一个临时文件，后面在处理数据时将数据写入此文件；</p>
</blockquote>
<blockquote>
<p>preCommit，在预提交阶段，刷写（flush）文件，然后关闭文件，之后就不能写入到文件了，我们还将为属于下一个检查点的任何后续写入启动新事务；</p>
</blockquote>
<blockquote>
<p>commit，在提交阶段，我们将预提交的文件原子性移动到真正的目标目录中，请注意，这会增加输出数据可见性的延迟；
abort，在中止阶段，我们删除临时文件。</p>
</blockquote>
<h3 id="flink-kafka-exactly-once">Flink-Kafka Exactly-once</h3>
<p><figure><img src="/images/ring.svg" data-src="/images/Exactly.png" data-sizes="auto" alt="Exactly" title="Exactly" class="lazyload"><figcaption class="image-caption">Exactly</figcaption></figure></p>
<p>如上图所示，我们用 Kafka-Flink-Kafka 这个案例来介绍一下实现“端到端精确一次”语义的过程，整个过程包括：</p>
<ul>
<li>从 Kafka 读取数据</li>
<li>窗口聚合操作</li>
<li>将数据写回 Kafka</li>
</ul>
<p>整个过程可以总结为下面四个阶段：</p>
<ul>
<li>一旦 Flink 开始做 checkpoint 操作，那么就会进入 pre-commit 阶段，同时 Flink JobManager 会将检查点 Barrier 注入数据流中 ；</li>
<li>当所有的 barrier 在算子中成功进行一遍传递，并完成快照后，则 pre-commit 阶段完成；</li>
<li>等所有的算子完成“预提交”，就会发起一个“提交”动作，但是任何一个“预提交”失败都会导致 Flink 回滚到最近的 checkpoint；</li>
<li>pre-commit 完成，必须要确保 commit 也要成功，上图中的 Sink Operators 和 Kafka Sink 会共同来保证。</li>
</ul>
<h3 id="现状">现状</h3>
<p>目前 Flink 支持的精确一次 Source 列表如下表所示，你可以使用对应的 connector 来实现对应的语义要求：</p>
<table>
<thead>
<tr>
<th align="center">数据源</th>
<th align="center">语义保证</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Apache Kafka</td>
<td align="center">exactly once</td>
<td align="center">需要对应的 Kafka 版本</td>
</tr>
<tr>
<td align="center">AWS Kinesis Streams</td>
<td align="center">exactly once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">RabbitMQ</td>
<td align="center">at most once (v 0.10) / exactly once (v 1.0)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Twitter Streaming API</td>
<td align="center">at most once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Collections</td>
<td align="center">exactly once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Files</td>
<td align="center">exactly once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Sockets</td>
<td align="center">at most once</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<p>如果你需要实现真正的“端到端精确一次语义”，则需要 sink 的配合。目前 Flink 支持的列表如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">写入目标</th>
<th align="center">语义保证</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">HDFS rolling sink</td>
<td align="center">exactly once</td>
<td align="center">需要对应的 Kafka 版本</td>
</tr>
<tr>
<td align="center">Elasticsearch</td>
<td align="center">at least once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Kafka producer</td>
<td align="center">at least once / exactly once</td>
<td align="center">需要 Kafka 0.11 及以上</td>
</tr>
<tr>
<td align="center">Cassandra sink</td>
<td align="center">at least once / exactly once</td>
<td align="center">幂等更新</td>
</tr>
<tr>
<td align="center">AWS Kinesis Streams</td>
<td align="center">at least once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">File sinks</td>
<td align="center">at least once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Socket sinks</td>
<td align="center">at least once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Standard output</td>
<td align="center">at least once</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Redis sink</td>
<td align="center">at least once</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>由于强大的异步快照机制和两阶段提交，Flink 实现了“端到端的精确一次语义”，在特定的业务场景下十分重要，我们在进行业务开发需要语义保证时，要十分熟悉目前 Flink 支持的语义特性。</p>
<p>这一课时的内容较为晦涩，建议你从源码中去看一下具体的实现。</p>
<p><a href="https://github.com/wangzhiwubigdata/quickstart">点击这里下载本课程源码</a>。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>追寻原风景 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-15/>https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-15/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://xiaohao890809.github.io/tags/42%E8%AE%B2%E8%BD%BB%E6%9D%BE%E9%80%9A%E5%85%B3flink/">
                    #42讲轻松通关Flink</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://xiaohao890809.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-14/" class="prev" rel="prev" title="第13讲：如何实现生产环境中的 Flink 高可用配置"><i class="iconfont icon-left"></i>&nbsp;第13讲：如何实现生产环境中的 Flink 高可用配置</a>
         
        
        <a href="https://xiaohao890809.github.io/2020/2020-07-20-the-lessons-of-flink-16/" class="next" rel="next" title="第15讲：如何排查生产环境中的反压问题">第15讲：如何排查生产环境中的反压问题&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
        
        
    </div>

</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2015 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://xiaohao890809.github.io">追寻原风景</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>













    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>

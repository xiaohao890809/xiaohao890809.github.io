<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>排序 on 枕霞惜友</title><link>https://xiaohao890809.github.io/tags/%E6%8E%92%E5%BA%8F/</link><description>Recent content in 排序 on 枕霞惜友</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 11 Jan 2018 23:11:23 +0000</lastBuildDate><atom:link href="https://xiaohao890809.github.io/tags/%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>经典排序法之Python版</title><link>https://xiaohao890809.github.io/2018/2018-01-11-the-classic-sorts/</link><pubDate>Thu, 11 Jan 2018 23:11:23 +0000</pubDate><guid>https://xiaohao890809.github.io/2018/2018-01-11-the-classic-sorts/</guid><description>大学的时候学习的经典算法忘记差不多了，现在赶紧拾起来，基本算法往往是复杂算法的基础，牢记掌握才是王道。
冒泡排序 def BubbleSorted(nums): length = len(nums) for i in range(length-1): for j in range(length-i-1): if nums[j]&amp;gt;nums[j+1]: nums[j],nums[j+1] = nums[j+1],nums[j] return nums 思考
如果原来的列表是有序列表呢，能否优化一下呢？
def bubble_sort(input_list): &amp;#34;&amp;#34;&amp;#34;冒泡排序&amp;#34;&amp;#34;&amp;#34; length = len(input_list) for j in range(length - 1): # 当列表已经是有序列表的，节省空间 count = 0 for i in range(length - j - 1): if input_list[i] &amp;gt; input_list[i+1]: input_list[i], input_list[i+1] = input_list[i+1], input_list[i] count += 1 if count == 0: return 属性：
最优时间复杂度：$O(n)$ (表示遍历一次没有发现任何可以交换的元素，排序结束) 最坏时间复杂度：$O(n^2)$ 稳定性：稳定 插入排序 def InsertSorted(nums): # 从第二元素开始直到最后一个元素 for i in range(1,len(nums)): tmp = nums[i] print(nums) j = i-1 while j &amp;gt;= 0 and nums[j] &amp;gt; tmp: nums[j+1] = nums[j] j = j - 1 nums[j+1] = tmp return nums 选择排序 def SelectSorted(nums): for i in range(len(nums)-1): minIndex = i for j in range(i+1,len(nums)): if nums[j] &amp;lt; nums[minIndex]: minIndex = j nums[i],nums[minIndex] = nums[minIndex],nums[i] return nums 图片来源：常用算法js版</description></item></channel></rss>